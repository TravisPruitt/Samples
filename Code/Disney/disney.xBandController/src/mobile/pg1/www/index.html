<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="format-detection" content="telephone=no" />
        <meta name="viewport" content="user-scalable=no, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width, height=device-height, target-densitydpi=device-dpi" />
	
		<link rel="stylesheet" href="css/jquery.mobile-1.2.0.min.css"/>

        <script>
            if (navigator.userAgent.match(/(iPhone|iPod|iPad|Android|BlackBerry)/)) {
                document.write('<script src="js/jquery-1.8.2.min.js" type="text/javascript"><' + '/script>');
                document.write('<script src="js/jquery.mobile-1.2.0.min.js" type="text/javascript"><' + '/script>');
                document.write('<script src="cordova-2.2.0.js" type="text/javascript"><' + '/script>');
            }
            else {
                document.write('<script src="js/jquery-1.8.2.js" type="text/javascript"><' + '/script>');
                document.write('<script src="js/jquery.mobile-1.2.0.js" type="text/javascript"><' + '/script>');
            }

            document.write('<script src="js/iscroll.js" type="text/javascript"><' + '/script>');
        </script>

		<style>

        @font-face {
            font-family: VAGRoundedStd;
            src: url("fonts/VAGRoundedStd-Light.otf") format("opentype");
        }

        @font-face {
            font-family: VAGRoundedStd;
            font-weight: bold;
            src: url("fonts/VAGRoundedStd-Bold.otf") format("opentype");
        }

        @font-face {
            font-family: VAGRoundedStd;
            font-weight: 900;
            src: url("fonts/VAGRoundedStd-Black.otf") format("opentype");
        }

        body {
            -webkit-user-select: none;
            font-family: VAGRoundedStd !important;
        }

        img.disneylogo {
            margin : auto;
            display : block;
            width : 160px;
        }

        body .ui-btn-up-a, body .ui-btn-hover-a, body .ui-btn-down-a,
        body .ui-btn-up-b, body .ui-btn-hover-b, body .ui-btn-down-b,
        body .ui-btn-up-c, body .ui-btn-hover-c, body .ui-btn-down-c,
        body .ui-btn-up-d, body .ui-btn-hover-d, body .ui-btn-down-d,
        body .ui-btn-up-e, body .ui-btn-hover-e, body .ui-btn-down-e {
            font-family: VAGRoundedStd;
        }

        body .ui-btn-up-e, body .ui-btn-hover-e, body .ui-btn-down-e {
            text-shadow : #9E8D33 0px 1px 0px;
        }

        body .ui-body-a,
        body .ui-body-b,
        body .ui-body-c,
        body .ui-body-d,
        body .ui-body-e {
            font-family: VAGRoundedStd;
            background-color: #aaa;
            background-image : none;
        }

        body .ui-bar-a,
        body .ui-bar-b,
        body .ui-bar-c,
        body .ui-bar-d,
        body .ui-bar-e {
            font-family: VAGRoundedStd;
        }

        label.ui-input-text.loginlabel {
            font-weight: bold;
            font-family: VAGRoundedStd;
        }

        .loginbuttonspacer {
            height:20px;
        }

        .readerBlueButtons {
            clear:both;
            display : none;
            position : relative;
            top : 5px;
        }

        .readerBlueButtons.gaAlwaysThere {
            display : block;
        }

        .readerBlueButtons .ui-btn.ui-shadow.ui-btn-corner-all.ui-btn-up-b,
        .readerBlueButtons .ui-btn.ui-shadow.ui-btn-corner-all.ui-btn-down-b,
        .readerBlueButtons .ui-btn.ui-shadow.ui-btn-corner-all.ui-btn-hover-b
        {
            display: inline-block;
            width: 48%;
        }

        .readerBlueButtons.gaAlwaysThere .ui-btn.ui-shadow.ui-btn-corner-all.ui-btn-up-b,
        .readerBlueButtons.gaAlwaysThere .ui-btn.ui-shadow.ui-btn-corner-all.ui-btn-down-b,
        .readerBlueButtons.gaAlwaysThere .ui-btn.ui-shadow.ui-btn-corner-all.ui-btn-hover-b
        {
            margin-top:0;
        }

        .readerBlueButtonIcon {
            height : 18px;
            margin-right : 10px;
        }

        .utilityheader, .utilitydivider {
            background-color : #464747;
            color : #fff;
            text-shadow : none;
            margin-right : -15px;
            margin-left : -15px;
            font-size : 14px;
            padding-top : 5px;
            padding-bottom : 3px;
            font-weight : bold;
            text-align : center;
        }

        #utilitycomment {
            min-height : 150px;
            background-image: none;
            margin: 0px;
            background-color: white;
            border: 1px;
            border-color: #333;
            border-style: solid;
        }

        .castmenuarrow {
            margin-left : 3px;
        }

        .whereAreYou {
            margin-top: 5px;
            font-weight: bold;
            color: white;
            text-shadow : none;
        }

        .logindiv {
            background-color : white;
            background-image : none;
            border-radius : 10px;
            box-shadow : 5px 5px 5px #777;
            padding : 10px;
        }

        .combinedviewitem.ui-li-static.ui-li {
            height : 29px;
            padding : 5px 10px 10px 52px;
            clear : both;
        }

        #portalid {
            background-image : none;
            background-color : #fff;
        }

        #password {
            background-image : none;
            background-color : #fff;
        }

        .ui-corner-all {
            border-radius : 5px;
        }

        .ui-btn-corner-all {
            -webkit-border-radius : 5px;
            border-radius : 5px;
        }

        .utilitypage {
            background-image : none;
            background-color : #999;
        }

        #combinedGreeterToggle {
            background-image: url("img/combinedgreetertoggle.png");
            height: 39px;
            width: 77px;
            background-size: 152px;
            background-position: 1px 0px;
            position: absolute;
            top: 1px;
            right: 5px;
        }

        #invisibleCombinedToggle {
            float: left;
            width: 38px;
            height: 38px;
        }

        #invisibleGreeterToggle {
            float: right;
            width: 38px;
            height: 38px;
        }

        #locationViewCastAction {
            background-image: url("img/castaction.png");
            height: 38px;
            width: 38px;
            background-size: 38px;
            float: left;
            position: absolute;
            top: 2px;
            left: 5px;
        }

        #combinedViewCastAction {
            background-image: url("img/castaction.png");
            height: 38px;
            width: 38px;
            background-size: 38px;
            float: left;
            position: absolute;
            top: 2px;
            left: 5px;
        }

        #loginPage {
            background-color : #999;
            background-image : none;
        }

        .readerstatetext .ui-li-heading {
            margin-top: 1px;
            margin-bottom: 5px;
        }

        .readerviewguest {
            float: right;
            margin-right: 4px;
        }

        #locationdetailsreaders {
            margin-bottom: 10px;
        }

        #locationDetails {
            background-color: #242424;
        }

        #locationDetails .utilitydivider {
            background-image: -webkit-linear-gradient(top, #333, #242424);
            border-bottom: 1px solid #333;
        }

        #locationDetails .readerstateicon {
            top: 4px;
            left: 4px;
        }

        #venueMap img, #venueMapLegend img {
            width: 320px;
        }

        #darkDiv {
            position : fixed;
            top: 0px;
            left : 0px;
            background-color : rgba(0, 0, 0, 0.5);
            height : 500px;
            width : 100%;
            display : none;
            z-index : 3;
        }

        #castActionMenu {
            display : none;
        }

        #notificationDetails {
            display: none;
            background-image: -webkit-linear-gradient(top, #F7F7F7, #CFCFCF);
            padding: 10px;
            position: relative;
            top: 70px;
            margin-left: auto;
            margin-right : auto;
            width : 90%;
            border-radius: 5px;
        }

        #darkDiv .pointyBit {
            left: 13px;
            position: relative;
            height: 15px;
            top : 43px;
        }

        #darkDiv .belowPointyBit {
            position: relative;
            left: 9px;
            background-color: #EEE;
            width: 200px;
            padding: 10px;
            border-radius : 5px;
            top : 43px;
        }

        .ui-li-has-count .ui-link-inherit .ui-li-count {
            padding: 3px 5px 0px 5px;
            font-size : 16px;
            margin-top: -13px;
        }

        .cast {
            float: right;
            padding-right: 5px;
        }

        .cast.closed {
            color : #999;
        }

        #greeterutilitypage {
            background-color: #242424;
        }

        div.gaContent {
            padding : 0px 0px 0px 3px;
        }

        div.gaContent div.gaPaddedItem {
            padding : 5px 7px 4px 7px;
            clear : both;
        }

        div.gaContent ul.gaList {
            margin-top: 1px;
            margin-bottom: 3px;
            background-color: #AAA;
            margin-left: -3px;
            margin-right: 0px;
        }

        div.gaContent ul.gaList li.gaListItem {
            padding: 0px;
            min-height: 0px;
            font-size: 18px;
        }

        div.gaContent ul.gaList li.gaListItem .gaListItem {
            padding: 5px 7px 4px 7px;
            min-height: 0px;
            font-size: 18px;
            overflow : hidden;
        }

        div.gaContent ul.gaList li.gaListItem img.gaIcon, .gaIcon {
            height: 40px;
            position: static;
            float: left;
            margin-right: 0px;
            vertical-align: middle;
        }

        div.gaContent ul.gaList li.gaListItem img.gaIcon.gaLargeIcon {
            height: auto;
            width: 128px;
            margin-left: auto;
            margin-right: auto;
            margin-bottom: 3px;
            display: block;
            float: none;
        }

        div.gaContent ul.gaList li.gaListItem img.gaIcon.gaMediumIcon {
            height: auto;
            width: 60px;
        }

        #confirmLogoutDiv {
            display : none;
            padding: 5px;
            background-color: white;
            border-radius: 5px;
        }

        #confirmLogoutDiv ul {
            padding : 0;
        }

        #confirmLogoutDiv li {
            list-style-type: none;
            background-color: white;
            padding: 5px;
            border-top: 1px solid #111;
        }

        #confirmLogoutDiv li:last-of-type {
            border-bottom: 1px solid #111;
        }

        div.gaContent ul.gaList li.gaListItem .gaListItem .gaLeftText {
            padding-left: 7px;
            margin-top: 9px;
            float : left;
        }

        div.gaContent ul.gaList li.gaListItem .gaListItem .gaLeftText.gaTight{
            margin-top: 0px;
            font-size: 16px;
        }

        .gaSuperScript {
            font-size : 14px;
            position : relative;
            top : 1px;
        }

        .gaSubScript {
            font-size : 14px;
            position : relative;
            top : -1px;
        }

        div.gaContent ul.gaList li.gaListItem .gaListItem .gaRightText {
            float : right;
            margin-top : 9px;
        }

        div.gaContent ul.gaList li.gaListItem a.gaListItem .gaRightText {
            margin-right : 30px;
            martin-top : 9px
            float : right;
        }

        div.gaContent ul.gaList li.gaListItem.gaDivider {
            padding : 3px 3px 2px 5px;
            font-size : 15px;
            margin-top: 3px;
            background-color: #454545;
        }

        .gaCenter {
            text-align : center;
        }

        .gaOff {
            opacity : 0.3;
        }

        .gaHeader {
            margin-bottom : 5px;
        }

        div.gaContent ul.gaList li.gaListItem .gaListItem .gaRightText.gaHasSuperScript,
        div.gaContent ul.gaList li.gaListItem .gaListItem .gaRightText.gaHasSubScript {
            margin-top: 0;
        }

        div.gaContent ul.gaList li.gaListItem .gaListItem .gaLeftText.gaHasSuperScript,
        div.gaContent ul.gaList li.gaListItem .gaListItem .gaLeftText.gaHasSubScript {
            margin-top: 0;
        }

        .gaMap {
            overflow : auto;
            padding : 0px;
            background-color : white;
        }

        .gaSelectorText {
            position: relative;
            top: 2px;
            margin-left : 5px;
        }

        .gaSelectorIcon {
            background-image: url('img/radio.png');
            background-size: 50px 25px;
            width: 25px;
            height: 25px;
            display: inline-block;
            vertical-align: middle;
        }
        .gaSelectorButton {
            padding-top: 10px;
            padding-bottom: 10px;
            border-bottom: solid 1px #DDD;
            font-weight: bold;
            cursor: pointer;
        }

        #venueSelector {
            width: 80%;
            margin-left: auto;
            margin-right: auto;
            margin-top: 20px;
            padding: 10px;
            background-color: #EEE;
            border-radius: 5px;
        }

        #coordinatorModeSelector {
            display : none;
        }

        div.venueLabel {
            background-image: -webkit-linear-gradient(top, #80B981, #72AA6F);
            text-shadow: #197220 0px 1px 0px;
            color: white;
        }

        .gaWarning {
            font-weight: bold;
            font-size: 20px;
        }

        #appVersion {
            font-size: 10px;
            margin-top: 10px;
            margin-right: 5px;
            text-align: right;
        }

        </style>
		<script>

			"use strict";

			// establish xConnect namespace
			var xConnect = xConnect || {};

			// add event dispatcher component to xConnect
			(function () {
				xConnect.eventDispatcher = {
					handlers : {},
					readerEventType : "readerEvent",
					locationStateChangeType : "locationStateChange",
					myLocationsType : "myLocations",
					greeterStateChangeType : "greeterStateChange",
					dispatchers : {
						readerEvent : function(message) {
							// {"version":"1.0","type":"readerEvent","reader":{"state":"open","lights":"green","name":"V1-1"},
							// "guest":{"firstName":"Bob","lastName":"Bobinski","celebrations":[{"name":"Birthday","date":"2011-01-23"},
							// {"name":"Wedding Aniversary","date":"2011-01-23"}]}}
							var event = {
								name : message.reader.name,
								message : message
							};
							xConnect.eventDispatcher.dispatch(event);
						},
						locationStateChange : function(message) {
							//{"version":"1.0","type":"locationStateChange","location":{"name":"MK1-V1","response":"success",
							// "byWhom":{"portalId":"John","omniId":"1234567891"},"readers":[{"state":"closed","lights":"off","name":"V1-1"},
							//{"state":"shutdown","lights":"off","name":"V1-2","errorCode":"readerNotResponding","errorDescription":"Reader is not saying Hello"}]}}

							var event = {
								name : message.location.name,
								message : message
							};
							xConnect.eventDispatcher.dispatch(event);
						}
					},
					unregister : function ( topic, handler ) {
						var index = -1,
							handlers = xConnect.eventDispatcher.handlers;
						
						if(handlers[topic]) { // are there even any handlers registered to that topic?
							index = handlers[topic].indexOf(handler);
						}
						
						if( index != -1 ) {
							handlers[topic].splice(index,1);
						}
					},
					register : function ( topic, handler ) {
						var handlers = xConnect.eventDispatcher.handlers;
						
						if( !handler || !topic ) {
							console.log('Ignoring attempt to register ' + topic + " and " + handler );
							return;
						}
						
						// don't allow the same handler to register more than once
						xConnect.eventDispatcher.unregister(topic, handler);
						
						// don't allow multiple registrations for the same event and handler
						xConnect.eventDispatcher.unregister(topic,handler);
						
						if( false === handlers.hasOwnProperty( topic )) {
							handlers[topic] = [];
						}
						handlers[topic].push(handler);
					},
					dispatch : function (e) {
						var handlers = xConnect.eventDispatcher.handlers;
						if( handlers.hasOwnProperty( e.name )) {
							handlers[e.name].forEach( function( handler ) {
								handler(e);
							});
						}
					}
				};
			
			}());

			// add the data component to the namespace
			(function () {
				xConnect.data = {
					userRegistry : "",
					readerIconNames : {
						off : "Ready",
						green : "Green",
						blue : "Blue",
						shutdown : "Shutdown",
						closed : "Closed"
					},
					xBRCAuthenticationUrl : "/UI/login/gettoken.action",
                    xBRMSAuthenticationUrl : "/XBRMS/login/gettoken.action",
					xbrcPort : '8080',
					ajaxTimeout : 5000,
					authenticationPort : '8090',
					sslAuthenticationPort : '8091',
					useSSLForAuth : false,
					greenTimeout : 5000, // fade green event to off after 5 seconds
					normalSubscribeTimeout : 59000,
                    defaultXbrcTimeout : 4000,
					subscribeTimeout : 0,
					subscribeErrorTimeout : 5000,
					xbrmsFacilitiesURL : "/XBRMS/rest/facilities",
					xbrcCurrentConfigurationURL : "/currentconfiguration",
					vipaddressString : "vipaddress",
					xbrcLocationInfoURL : "/readerlocationinfo",
					xbrcStatusURL : "/status",
					xbrcMessageUrl : "/model/greeter/message",
					xbrcSubscribeUrl : "/model/greeter/subscribe",
					parkEntryModelString : "parkentrymodel",
					masterModeString : 'master',
					soloModeString : 'solo',
					greeterRoleString : "x-greeter",
					coordinatorRoleString : "x-coordinator",
					venue: "Unknown",
                    xbrcSystemOfflineString: "Communication Error/Reconnecting...",
					xbrmslist : [],
					xbrclist : [],
					venueMapBase : 'img/',
					locationIconBase : "img/location",
					GUID : "",
					deviceId : "00:00:00:00:00:00",
					venueToCode : { 
					                "Magic Kingdom" : "mk",
					                "Animal Kingdom" : "ak",
					                "Hollywood Studios" : "hs",
					                "Epcot" : "ep",
					                "Downtown Disney" : "dd",
					                "Disney Quest" : "dq",
					                "ESPN" : "wwos",
					                "Blizzard Beach" : "bb",
					                "Typhoon Lagoon" : "tl",
					                "Alpha Lab" : "al",
                                    "Synapse SIT" : "ss",
                                    "Synapse Master" : "sm",

					                // Use the Magic Kingdom settings for demo mode
					                "Demo" : "de"
					},
					setGUID : function ()
						{
							var S4 = function ()
							{
								return Math.floor(
										Math.random() * 0x10000 /* 65536 */
									).toString(16);
							};

							xConnect.data.GUID = S4() + S4() + "-" +
									S4() + "-" +
									S4() + "-" +
									S4() + "-" +
									S4() + S4() + S4();
						},
					setVenue : function(venue) {
						console.log("setting venue:"+venue+"\n");
						xConnect.data.venue = venue;
						xConnect.data.venueCode = xConnect.data.venueToCode[venue];
						
						// load the correct venue map into the venue map page
						xConnect.utilities.initializeVenueMap();

                        var myScroll = new iScroll('mapwrapper', { zoom: true });

						// save the venue location selection for next time
						xConnect.utilities.saveVenueToSettings();
						
						xConnect.data.showVenue();
					},
					showVenue : function() {
						xConnect.combinedView.showVenue();
						xConnect.locationView.showVenue();
					},
					user: {
						actions : {
							resetUser : function(){
								xConnect.data.user.id = xConnect.data.user.defaultId;
								xConnect.utilities.selectors.values.coordinatorModeSelector = "Coordinator";
								xConnect.utilities.decorateSelector($('#coordinatorModeSelector'));
							}
						},
						role: "unknown",
						defaultId : {
							portalId : "unknown",
							omniId : "unknown",
							omniPassword : "unknown"
							},
						id: {
							portalId : "unknown",
							omniId : "unknown",
							omniPassword : "unknown"
							},
						myLocations : [],
						getMyReadersCount : function() {
							var numberOfReaders = 0;
							
							xConnect.data.user.myLocations.forEach(function(location) {
								numberOfReaders += location.readers.length;
							});
							
							return numberOfReaders;
						}
					},
					xbrcs : {
						actions : {
							wentOffline : function(xbrc) {
								var locationList = xConnect.data.locations.list,
									messageType = xConnect.eventDispatcher.locationStateChangeType;
								
								xbrc.isOffline = true;
								
								console.log("wentOffline");
								xConnect.data.subscribeTimeout = xConnect.data.subscribeErrorTimeout;
								
								// find all the locations associated with this xbrc and trigger decoration
								locationList.forEach(function(location) {
								console.log("location:" + location.name);
									if( location.xbrc == xbrc ) {
								console.log("locxbrc:"+ location.xbrc.url + " == " + xbrc.url);
										// now pass the message downstream to the UI components
										xConnect.eventDispatcher.dispatchers[messageType]({location:location, message:{location:location}});
										console.log("dispatched");
                                        
                                        // generate reader events from the location State Change
                                        xConnect.data.locations.actions.sendReaderEventsFromLocationStateChange( location );
                                    }
								});
								
							},
							wentOnline : function(xbrc) {
                                xbrc.isOffline = false;
                                console.log("wentOnline");

								xConnect.utilities.resynchWithXbrcs();
								xConnect.data.subscribeTimeout = xConnect.data.normalSubscribeTimeout;
                                xConnect.utilities.subscribeToEventsForXbrc(xbrc);
                            }
						}
					},
					locations: {
						list : [],
						readerList : [],
						actions : {
							handleLocationEvent : function(e) {
								var location = xConnect.data.locations.actions.findLocationByName(e.message.location.name),
									cast = e.message.location.cast || e.message.location.byWhom,
									actionInitiator = cast ? cast.portalId : undefined,
									triggerLocationStatus = false,
									previousGreeterName = "",
									newGreeterName = "";
								

								// hack until we fix the xbrc to return "bywhom"

/*								if(!cast) { // check to see if we just initiated something with this location
									if(xConnect.data.locations.hack_lastLocationAction == e.message.location.name ) {
										delete xConnect.data.locations.hack_lastLocationAction;
										actionInitiator = xConnect.data.user.id.portalId;
									} else {
										actionInitiator = "someoneelse";
									}
								} else {
									actionInitiator = cast.portalId;
									if(xConnect.data.locations.hack_lastLocationAction == e.message.location.name ) {
										delete xConnect.data.locations.hack_lastLocationAction;
									}
								}
*/

                                // ****  these next few lines are required to accommodate changes to the messages from XBRC
                                // we need to ignore any location state changes that have closed state and contain a cast
								var tempcast = e.message.location.cast;
								xConnect.utilities.rollupLocationState(e.message.location);
								if( tempcast && e.message.location.state == "closed" ) {
									return;
								}
                				// ******
				
								if( location ) {
									// we found it! 
								} else {
									// Add it?? ignore it?? ...
									// trigger locationStatus to see if the xBRC knows what to do with it.
									triggerLocationStatus = true;
									console.log("unknown location: "+e.message.location.name);
									return;
								}
								
								if( triggerLocationStatus && xConnect.data.mode != "Demo" ) { // don't resync during demo
									xConnect.utilities.resynchWithXbrcs();
								}

								previousGreeterName = location.cast ? location.cast.portalId : ""; // save the current greeter name associated with the location
								
								xConnect.utilities.copyLocationData(e.message.location, location);
								
								// generate reader events from the location State Change
								xConnect.data.locations.actions.sendReaderEventsFromLocationStateChange( location );
								
								if( location.state == "open" ) {
									// there is a new greeter associated with the location
									newGreeterName = location.cast.portalId;
								}
								
								// am I a greeter?
								if( xConnect.utilities.actingAsGreeter() ) {
									//actionInitiator = location.cast ? location.cast.portalId : xConnect.data.user.id.portalId;
									// if I didn't initiate the action ... 
									if( xConnect.data.user.id.portalId != "unknown" && xConnect.data.user.id.portalId != actionInitiator ) {
										// do I have this location open?
										if( xConnect.data.locations.actions.findByName(xConnect.data.user.myLocations, location.name) ) {
											if( location.state == "open" ) { // if the new locatinon is open ... we're being bumped
												// set up bump notification page, then transition to it ...
												xConnect.utilities.bumpNotificationPageInit(location, actionInitiator);
												xConnect.utilities.showNotificationPage();
												//$.mobile.changePage('#bumpNotificationPage');
											} else { // the location was closed / shutdown by a coordinator
												// set up close notification page, then transition to it ...
												xConnect.utilities.closeNotificationPageInit(location, actionInitiator);
												xConnect.utilities.showNotificationPage();
												//$.mobile.changePage('#closeNotificationPage');
											}
										}
									}
								}
								
								// remove any locations from our selected location list if someone else is marked as owning them
								// add any locations to our list if we are marked as owning them
								xConnect.utilities.populateMyLocations();

								// now pass the message downstream to the UI components
								xConnect.eventDispatcher.dispatchers[e.message.type]({location:location, message:{location:location}});
								
								// now create a greeterStateChange for the greeters as necessary
								if( previousGreeterName ) {
									xConnect.eventDispatcher.dispatch({name:xConnect.eventDispatcher.greeterStateChangeType, message:{location:location, greeterName:previousGreeterName}});
								}
								if( newGreeterName ) {
									xConnect.eventDispatcher.dispatch({name:xConnect.eventDispatcher.greeterStateChangeType, message:{location:location, greeterName:newGreeterName}});
								}
							},
							sendReaderEventsFromLocationStateChange : function( location ) {
								
								location.readers.forEach(function(reader){
									// reuse existing incoming readerEvent logic with manufactured readerEvent
									// reader data is already copied as part or handling the locationStateChange event
									xConnect.eventDispatcher.dispatchers[xConnect.eventDispatcher.readerEventType]({reader:reader});
								});
							},
							handleReaderEvent : function(e) {
								var readerItem = xConnect.data.locations.actions.findReaderByName(e.message.reader.name),
									triggerLocationStatus = false,
									reader = {};
								
								if( readerItem ) { 
									// we found it!
									reader = readerItem.reader;
									if( readerItem.location.state != "open" ) {
										// we just received a reader event for a non-open location ... something's screwy
										triggerLocationStatus = true;
									}
								} else {
									// Add it?? to which location?? ignore it?? ...
									// trigger locationStatus to see if the xBRC knows what to do with it.
									triggerLocationStatus = true;
									console.log("unknown touch point: "+e.message.reader.name);
									return;
								}
								
								if( triggerLocationStatus && xConnect.data.mode != "Demo" ) { // don't resync during demo
									xConnect.utilities.resynchWithXbrcs();
								}
								
								// if the xbrc tells us how long to show green lights for ... use it
								if(e.message.reader.lightDuration) {
									xConnect.data.greenTimeout = e.message.reader.lightDuration;
								}
								// copy the new reader state from the message
								xConnect.utilities.copyReaderData(e.message.reader, reader);
								// copy the guest (inlcuding celebrations) information over too
								reader.guest = e.message.guest;
																
								// now pass the message downstream to the UI components
								xConnect.eventDispatcher.dispatchers[e.message.type]({reader:reader});
							},
							compare : function(name1, name2 ) {
								var reg = /([a-zA-Z-_]+)([0-9]+)-(\w+)/,
									strings1 = name1.match(reg),
									strings2 = name2.match(reg),
									venuePrefix1 = name1,
									inst1 = 0,
									rest1 = '',
									venuePrefix2 = name2,
									inst2 = 0,
									rest2 = '';
								
								// now check to see if the location name conforms to the regular expression and if not ... default to using it as a string
								if( strings1 ) {
									venuePrefix1 = strings1[1];
									inst1 = parseInt(strings1[2]);
									rest1 = strings1[3];
								}
								if( strings2 ) {
									venuePrefix2 = strings2[1];
									inst2 = parseInt(strings2[2]);
									rest2 = strings2[3];
								}
								
								if(venuePrefix1 > venuePrefix2 ) {
									return 1;
								}
								if(venuePrefix1 < venuePrefix2 ) {
									return -1;
								}
								// venue prefixes are the same
								if(inst1 > inst2) {
									return 1;
								}
								if(inst1 < inst2) {
									return -1;
								}
								// same venue and installation #
								if(rest1 > rest2) {
									return 1;
								}
								if(rest1 < rest2 ) {
									return -1;
								}
								
								return 0;
							},
							compareReaders : function(name1, name2 ) {
								var reg = /([a-zA-Z-_]+)([0-9]+)-(\w+)-(\w+)/,
									strings1 = name1.match(reg),
									strings2 = name2.match(reg),
									venuePrefix1 = name1,
									inst1 = 0,
									loc1 = '',
									read1 = '',
									venuePrefix2 = name2,
									inst2 = 0,
									loc2 = '',
									read2 = '';
								
								// now check to see if the location name conforms to the regular expression and if not ... default to using it as a string
								if( strings1 ) {
									venuePrefix1 = strings1[1];
									inst1 = parseInt(strings1[2]);
									loc1 = strings1[3];
									read1 = strings1[4].toLowerCase();
								}
								if( strings2 ) {
									venuePrefix2 = strings2[1];
									inst2 = parseInt(strings2[2]);
									loc2 = strings2[3];
									read2 = strings2[4].toLowerCase();
								}
								
								if(venuePrefix1 > venuePrefix2 ) {
									return 1;
								}
								if(venuePrefix1 < venuePrefix2 ) {
									return -1;
								}
								// venue prefixes are the same
								if(inst1 > inst2) {
									return 1;
								}
								if(inst1 < inst2) {
									return -1;
								}
								// same venue and installation #
								if(loc1 > loc2) {
									return 1;
								}
								if(loc1 < loc2 ) {
									return -1;
								}
								
								// same venue, installation # and location
								// special case for Front and Back ... order Front first...
								if( read1 == "front" && read2 == "back" ) {
									return -1;
								}
								
								if( read1 == "back" && read2 == "front" ) {
									return 1;
								}
								
								// ok, now just process the reader suffixes alphabetically
								if(read1 > read2) {
									return 1;
								}
								if(read1 < read2 ) {
									return -1;
								}
								
								return 0;
							},
							findByName : function(list, name) {
								var result;
								
								list.forEach(function(item){
									if(item.name == name){
										result = item;
									}
								});
								
								return result;
							},
							findReaderInLocation : function(location, readerName ) {
								return xConnect.data.locations.actions.findByName(location.readers, readerName );
							},
							findReaderByName : function( readerName ) {
								var item = xConnect.data.locations.actions.findByName(xConnect.data.locations.readerList, readerName );
								
								return item;
							},
							findLocationByName : function(locationName) {
								return xConnect.data.locations.actions.findByName(xConnect.data.locations.list, locationName);
							},
							openLocation : function(location, cast, callback) {
								// {"version":"1.0","type":"openLocation","clientReference":"77777777","sessionId":"95DB6F5A-17F6-11E2-BF6A-980B6188709B",
								//	"cast":{"portalId":"Arek","omniId":"1234567890","omniPassword":"password"},"locationName":"Entry-New"}

								var request = { version : "1.0",
												type : "openLocation",
												clientReference : xConnect.utilities.generateClientReference(),
												sessionId : xConnect.data.GUID,
												cast : xConnect.data.user.id,
												locationName : location.name
											},
									urlString = location.xbrc.url + xConnect.data.xbrcMessageUrl;
								
								// hack until xbrc sends byWhom
//								xConnect.data.locations.hack_lastLocationAction = location.name;
								
								xConnect.utilities.ajax( location.xbrc, urlString, request, (function() {
											return function(data, textStatus, jqXHR){
												var myReader = {};
									
											// {"version":"1.0","type":"openLocationResponse","clientReference":"77777777","location":
											// {"name":"MK1-V1","response":"error","errorDescription":"Reader V1-2 is not responding.","errorCode":"readerNotResponding",
											//	"cast":{"portalId":"Tony","omniId":"1234567890"},"readers":[{"state":"open","lights":"off","name":"V1-1"},
											// {"state":"shutdown","lights":"off","name":"V1-2","errorCode":"readerNotResponding","errorDescription":"Reader is not saying Hello"}]}}
											if( data.location ) {
												if( data.location.response == "error" ) {
													console.log("Error in open Location :" + data.location.errorCode);
													console.log(data.location.errorDescription);
													xConnect.utilities.errorNotificationPageInit("Open Location Error", data.location.errorDescription );
													xConnect.utilities.showNotificationPage();
													if( data.location.errorCode == "loginFailed" ) {
														// regather Omni ID
													} else {
														// show error page
													}
												} else {
													location.cast = cast;
													// resubscribe to this xbrc to get events from this reader
													xConnect.utilities.subscribeToEventsForXbrc(location.xbrc);
												}
											} else {
												console.log("received an empty response from xbrc");
												xConnect.utilities.errorNotificationPageInit("Open Location Error", "Received an empty response from XBRC" );
												xConnect.utilities.showNotificationPage();
											}
											
											if(callback) {
												callback();
											}
										};
								}()));
							},
							closeLocation : function(location, callback) {
								// {"version":"1.0","type":"closeLocation","clientReference":"77777777","sessionId":"95DB6F5A-17F6-11E2-BF6A-980B6188709B",
								//	"cast":{"portalId":"Tony","omniId":"1234567890"},"locationName":"MK1-V1"}
								var request = { version : "1.0",
												type : "closeLocation",
												clientReference : xConnect.utilities.generateClientReference(),
												sessionId : xConnect.data.GUID,
												cast : {
													portalId : xConnect.data.user.id.portalId,
													omniId : xConnect.data.user.id.omniId
													},
												locationName : location.name
											},
									urlString = location.xbrc.url + xConnect.data.xbrcMessageUrl;
								
								// hack until xbrc sends byWhom
//								xConnect.data.locations.hack_lastLocationAction = location.name;
								
								xConnect.utilities.ajax( location.xbrc, urlString, request, (function() {
											return function(data, textStatus, jqXHR){
												var myReader = {};
									
											// {"version":"1.0","type":"closeLocationResponse","clientReference":"77777777","location":{
											// "name":"MK1-V1","response":"success","byWhom":{"portalId":"Tony","omniId":"1234567890"},"readers":[
											// {"state":"closed","lights":"off","name":"V1-1"},{"state":"shutdown","lights":"off","name":"V1-2",
											// "errorCode":"readerNotResponding","errorDescription":"Reader is not saying Hello"}]}}
											if( data.location ) {
												if( data.location.response == "error" ) {
													xConnect.utilities.errorNotificationPageInit("Close Location Error", data.location.errorDescription );
													xConnect.utilities.showNotificationPage();
												} else {
													delete location.cast;
												}
											} else {
												console.log("received an empty response from xbrc");
												xConnect.utilities.errorNotificationPageInit("Close Location Error", "Received an empty response from XBRC" );
												xConnect.utilities.showNotificationPage();
											}
											
											if(callback) {
												callback();
											}
										};
								}()));
							}, 
							bumpLocation : function(location, cast, callback) {
								// {"version":"1.0","type":"bumpLocation","clientReference":"77777777","sessionId":"95DB6F5A-17F6-11E2-BF6A-980B6188709B",
								//	"cast":{"portalId":"Arek","omniId":"1234567890","omniPassword":"password"},"locationName":"Entry-New"}
								var request = { version : "1.0",
												type : "bumpLocation",
												clientReference : xConnect.utilities.generateClientReference(),
												sessionId : xConnect.data.GUID,
												cast : xConnect.data.user.id,
												locationName : location.name
											},
									urlString = location.xbrc.url + xConnect.data.xbrcMessageUrl;
								
								// hack until xbrc sends byWhom
//								xConnect.data.locations.hack_lastLocationAction = location.name;
								
								xConnect.utilities.ajax( location.xbrc, urlString, request, (function() {
											return function(data, textStatus, jqXHR){
												var myReader = {};
									
												// {"version":"1.0","type":"bumpLocationResponse","clientReference":"77777777","location":
												// {"name":"MK1-V1","response":"error","errorDescription":"Reader V1-2 is not responding.","errorCode":"readerNotResponding",
												//	"cast":{"portalId":"Tony","omniId":"1234567890"},"readers":[{"state":"open","lights":"off","name":"V1-1"},
												// {"state":"shutdown","lights":"off","name":"V1-2","errorCode":"readerNotResponding","errorDescription":"Reader is not saying Hello"}]}}
												if( data.location ) {
													if( data.location.response == "error" ) {
														xConnect.utilities.errorNotificationPageInit("Bump Location Error", data.location.errorDescription );
														xConnect.utilities.showNotificationPage();
													} else {
														location.cast = cast;
														// resubscribe to this xbrc to get events from this reader
														xConnect.utilities.subscribeToEventsForXbrc(location.xbrc);
													}
												} else {
													console.log("received an empty response from xbrc");
													xConnect.utilities.errorNotificationPageInit("Bump Location Error", "Received an empty response from XBRC" );
													xConnect.utilities.showNotificationPage();
												}
												
												if(callback) {
													callback();
												}
											};
								}()));
							}
						}
					}
				};
			}());

			// add location view componenet to xConnect
			(function () {
				xConnect.locationView = {
					pageInit : function() {
						$("#myReadersButton").on('click', xConnect.readerView.loadReaders);
						$('#locationViewCastAction').on('click', xConnect.utilities.castAction);
                        $('#locationViewXbrcStatus').on('click', xConnect.utilities.xbrcStatus);
						xConnect.data.showVenue();
						xConnect.eventDispatcher.register(xConnect.eventDispatcher.myLocationsType, xConnect.locationView.handleMyLocationsEvent );
					},
					handleMyLocationsEvent : function(e) {
						xConnect.locationView.decorateMyReadersButton();
					},
					setup : function() {
						$("#greeterid").text(xConnect.data.user.id.portalId);
						xConnect.locationView.loadLocations();
					},
					decorateMyReadersButton : function() {
						// if myLocations has changed, check whether we should be enabling the myreaders button
						var numberOfReaders = xConnect.data.user.getMyReadersCount();
						
						xConnect.locationView.setMyReadersCount();
						if(numberOfReaders == 0) {
							xConnect.locationView.disableMyReadersButton();
						} else {
							xConnect.locationView.enableMyReadersButton();
						}
					},
					setMyReadersCount : function() {
						var numberOfReaders = xConnect.data.user.getMyReadersCount();
						
						$('#myReadersButton .ui-li-count').text(numberOfReaders);
					},
					disableMyReadersButton : function() {
						var myReadersWidget = $('#myReadersButton'),
							myReadersLineItem = $('#myReadersLineItem');
						
						myReadersWidget.addClass('ui-disabled');
						
						myReadersLineItem.attr('data-theme','c');
						myReadersLineItem.removeClass('ui-btn-up-e');
						myReadersLineItem.removeClass('ui-btn-hover-e');
						myReadersLineItem.removeClass('ui-btn-down-e');
						myReadersLineItem.addClass('ui-btn-up-c');
					},
					enableMyReadersButton : function() {
						var myReadersWidget = $('#myReadersButton'),
							myReadersLineItem = $('#myReadersLineItem');
						
						myReadersWidget.removeClass('ui-disabled');
						
						myReadersLineItem.attr('data-theme','e');
						myReadersLineItem.removeClass('ui-btn-up-c');
						myReadersLineItem.addClass('ui-btn-up-e');
					},
					showVenue : function() {
						var nameWidget = $("#locationView .venueName");
						nameWidget.text(xConnect.data.venue);
					},
					handleLocationEvent : function(e) {
						xConnect.locationView.decorateLocation(e.message.location);
					},
					insertLocation : function(list, location ) {
						var listItems = list.find("li"),
							listIndex = 1,
							listLength = listItems.length,
							listItemName = "",
							locationName = location.find("[data-bind='name']").text();
						
						// find the right place in the sorted list to insert the location
						// skipping the header (ie: start at 1 not 0)
						for( listIndex = 1; listIndex < listLength; listIndex++) {
							listItemName = $(listItems[listIndex]).find("[data-bind='name']").text();
							if( 1 != xConnect.data.locations.actions.compare( locationName, listItemName ) ) {
								// if the locationName is equal or before the listItem
								break;
							}
						}
						if( listIndex == listLength ) {
							list.append(location);
						} else {
							location.insertBefore(listItems[listIndex]);
						}
					},
					decorateLocation : function(location) {
						var locationCast = location.cast ? location.cast.portalId : "",
							locationItem = $("#locationviewtemplate-"+location.label),
							castNameWidget = locationItem.find("[data-bind='castid']"),
							locationIcon = xConnect.data.locationIconBase + "-" + location.state + ".png",
							locationStatusWidget = locationItem.find('[data-bind="status"]'),
							castName = "",
							currentList = locationItem.closest("ul"),
							currentListName = currentList.find("li[data-role='list-divider']").text(),
							otherList = currentList.siblings("ul");
						
						if( location.state == 'shutdown' ) {
							locationStatusWidget.text(location.readers[0].errorCode);
						} else {
							if( location.xbrc.isOffline ) {
								locationStatusWidget.text(xConnect.data.xbrcSystemOfflineString);
							} else {
								locationStatusWidget.text(location.stateName);
							}
						}
						
						if( xConnect.data.user.id.portalId == locationCast && locationCast != "") { // if it's one of our locations and our id isn't ""
							castName = "me";
							if( currentListName != "My Locations" ) { // if this location is currently in the wrong list move it
								xConnect.locationView.insertLocation(otherList, locationItem );
							} // else do nothing
						} else { // it's an "other location"
							castName = locationCast;
							if( currentListName != "Other Locations" ) { // if it's currently in the wrong list move it
								xConnect.locationView.insertLocation(otherList, locationItem );
							}
						}
						
						// set the cast name
						castNameWidget.text( castName );
												
						// set image source
						locationItem.find("img").prop( 'src', locationIcon);
						
						// set shutdown style if needed
						if( location.state == "shutdown" || location.xbrc.isOffline ) {
							xConnect.utilities.disableLink(locationItem);
						} else {
							xConnect.utilities.enableLink(locationItem);
						}
					},
					addLocations : function(locationHeader) {
						var locationList = xConnect.data.locations.list,
							newItem = {},
						    binder = xConnect.binder("#locationviewtemplate"),
						    castName = "";
							
							locationList.forEach(function(location) {
								newItem = binder({id:"locationviewtemplate-"+location.label, name:location.name, castid : castName || "" });
								// add the item to the DOM
								xConnect.locationView.insertLocation(locationHeader, newItem);
								// locationHeader.append(newItem);
								
								// make it look pretty
								xConnect.locationView.decorateLocation(location);
								
								xConnect.eventDispatcher.register( location.name, xConnect.locationView.handleLocationEvent );
								
								// set up the action call backs when a location is selected
								newItem.find('a').on('click', (function(){
									return function(e) {
										xConnect.locationDetails.setup(location);
									};
								}()));
							});
					},
					loadLocations : function () {
						var parentControl = $("#locationviewdiv"),
							existingElements = parentControl.find('[id^="locationviewtemplate"]'),
							locationHeader = {},
							locationInfo = [{ title:"My Locations", dividerTheme:'b'},{title:"Other Locations", dividerTheme:'a'}],
							dividerWidget = {};
						
						// add any items to our selected location list if we're marked as owning them
//						xConnect.utilities.populateMyLocations();
						xConnect.locationView.decorateMyReadersButton();
						
						parentControl.empty();
						
						locationInfo.forEach(function(info) {
							locationHeader = xConnect.binder("#locationviewheadertemplate")({id:"locationviewheadertemplate"+Math.random()});
							parentControl.append(locationHeader);						
							locationHeader.attr({'data-divider-theme' : info.dividerTheme});
							
						    dividerWidget = $(document.createElement("li"));
							dividerWidget.text(info.title);
							dividerWidget.attr({ 'data-role' : "list-divider" });
							dividerWidget.addClass('gaListItem gaDivider gaCenter');

							locationHeader.append(dividerWidget);
						});
						
						// add them all to the last locationHeader object (they'll be moved later)
						xConnect.locationView.addLocations(locationHeader);
			
						try {
							parentControl.trigger("create");
						} catch (e ) {
							// ignore failure
						}
					}
				};
			}());

			// add location details component to xConnect
			(function () {
				xConnect.locationDetails = {
					greyColor : "#dddddd",
					flashing : false,
					originalColor : "",
					originalImage : "",
					pageInit : function() {
						var myPage = $('#locationDetails');
						
						myPage.find('[data-role="header"] [data-rel="back"]').on('click', function(){
							xConnect.locationDetails.clearCallbacks();							
						});
					},
					flashOn : function(color ) {
						var flashButton = $("#flashbutton"),
							viewButton = flashButton.parent();
						
						if( !xConnect.locationDetails.originalColor ) { // only the first time through
							xConnect.locationDetails.originalColor = viewButton.css('background-color');
							xConnect.locationDetails.originalImage = viewButton.css('background-image');
						}

						viewButton.css({'background-image':"none"});
						viewButton.css({'background-color':color});
					},
					flashOff : function() {
						var flashButton = $("#flashbutton"),
							viewButton = flashButton.parent();
						
						viewButton.css({'background-color':xConnect.locationDetails.greyColor});
					},
					restoreFlashButton : function() {
						var flashButton = $("#flashbutton"),
							viewButton = flashButton.parent();
						
						viewButton.css({'background-image':xConnect.locationDetails.originalImage});
						viewButton.css({'background-color':xConnect.locationDetails.originalColor});
						
						xConnect.locationDetails.originalColor = '';
						xConnect.locationDetails.originalImage = '';

					},
					hideFlashButton : function() {
						var flashDiv = $("#locationdetailsflashdiv");
						
						flashDiv.css({'display':'none'});
					},
					showFlashButton : function() {
						var flashDiv = $("#locationdetailsflashdiv");
						
						flashDiv.css({'display':'block'});
					},
					actions : {
						MapSetup : function(location) {
							
						},
						Map : function(location) {
							
						}
					},
					locationActions : {
						Flash : function(location) {
							// {"version":"1.0","type":"flashLocation","clientReference":"77777777","sessionId":"95DB6F5A-17F6-11E2-BF6A-980B6188709B",
							// "locationName":"Entry-New"}

							var request = { version : "1.0",
											type : "flashLocation",
											clientReference : xConnect.utilities.generateClientReference(),
											sessionId : xConnect.data.GUID,
											locationName : location.name
										},
								flashButton = $("#flashbutton"),
								urlString = location.xbrc.url + xConnect.data.xbrcMessageUrl;
							
							if( xConnect.locationDetails.flashing ) {
									// abort if we're already flashing
									return;
							}
							xConnect.locationDetails.flashing = true;
							
							xConnect.utilities.ajax( location.xbrc, urlString, request, (function() {
										return function(data, textStatus, jqXHR){
											var numberOfFlashes = 6;
								
											// {"version":"1.0","type":"flashLocationResponse","clientReference":"77777777","location":{"name":"Entry-New",
											// "response":"success","readers":[{"state":"closed","lights":"off","name":"entry-1"},{"state":"closed",
											// "lights":"off","name":"entry-4"},{"state":"closed","lights":"off","name":"entry-3"},{"state":"closed",
											// "lights":"off","name":"entry-2"}],"flashColor":"#123322"}}
											if( data.location.response != 'success' ) {
												// too many people flashing
											}
											
											var flasher = function() {
												xConnect.locationDetails.flashOn(data.location.flashColor);
												setTimeout((function(){
													return function(){
														xConnect.locationDetails.flashOff();
														setTimeout((function(){
															return function() {
																if( --numberOfFlashes ) {
																	flasher();
																} else {
																	xConnect.locationDetails.restoreFlashButton();
																	xConnect.locationDetails.flashing = false;
																}
															};
														}()), 200);
													};
												}()), 300);
											};
											flasher();
										};
							}()));
						},
						Open : function(location) {
//							var myLocations = xConnect.data.user.myLocations;

							
							xConnect.data.locations.actions.openLocation(location, xConnect.data.user.id, (function(){
								return function(){
									xConnect.eventDispatcher.unregister( location.name, xConnect.locationDetails.handleLocationEvent );

									xConnect.locationDetails.clearCallbacks();
									
									history.back();
								};
							}()));
						},
						Close : function(location) {
							xConnect.data.locations.actions.closeLocation(location, (function(){
								return function() {
									// first see if the selection is already in our list
									xConnect.locationDetails.clearCallbacks();

									// mylocations list will be updated when the locationStateChange message comes back from xbrc
									// locationView will be updated when the locationStateChange message comes back from xbrc
									xConnect.eventDispatcher.unregister( location.name, xConnect.locationDetails.handleLocationEvent );

									history.back();
								};
							}()));
						},
						Bump : function(location) {
							xConnect.data.locations.actions.bumpLocation(location, xConnect.data.user.id, (function(){
								return function(){
									// mylocations list will be updated when the locationStateChange message comes back from xbrc
									// locationView will be updated when the locationStateChange message comes back from xbrc
									xConnect.eventDispatcher.unregister( location.name, xConnect.locationDetails.handleLocationEvent );
									
									xConnect.locationDetails.clearCallbacks();

									history.back();
								};
							}()));
						}
					},
					clearCallbacks : function() {
						var locationDetailsPage = $('#locationDetails');
						locationDetailsPage.find('.locationdetailsaction').off("click.xConnect.locationDetails");
					},
					setupCallbacks : function(location) {
						var locationDetailsPage = $('#locationDetails');
					
						locationDetailsPage.find('.locationdetailsaction').on("click.xConnect.locationDetails", (function() {
							return function(e){
								// use the first word of the button name as the action function name
								var action = $(e.target).text().split(" ")[0];
								
								console.log("Calling: " + action );
								if( xConnect.locationDetails.locationActions[action] ) {
									xConnect.locationDetails.locationActions[action](location);
								} else {
									alert("Undefined action '"+action+"' for location.");
								}
							}
						}()));
					},
					decorateView : function(location) {
						var locationDetailsPage = $('#locationDetails'),
							readersWidget = $('#locationdetailsreaders'),
							buttonWidget = $("#locationdetailsactionbutton"),
							locationHeader = locationDetailsPage.find('[data-role="header"] h1'),
							buttonText = "";
						
						locationHeader.text(location.name);
							
						xConnect.currentUtilityPage.actions = xConnect.locationDetails.actions;
	
	
						if( location.state == "closed" ) {
							buttonText = "Open This Location";
							xConnect.locationDetails.showFlashButton();
						} else if( location.state == "open" ) {
							xConnect.locationDetails.hideFlashButton();
							if( location.cast.portalId == xConnect.data.user.id.portalId ) {
								buttonText = "Close This Location";
							} else {
								buttonText = "Bump " + location.cast.portalId;
							}
						} else {
							xConnect.locationDetails.hideFlashButton();
							buttonText = "Not Available";
						}
						
						buttonWidget.siblings('.ui-btn-inner').find('.ui-btn-text').text(buttonText);
						buttonWidget.text(buttonText); // need this for the first time through because the button isn't decorated
						
						readersWidget.empty();
						location.readers.forEach(function(reader){
							var binder = xConnect.binder("#locationdetailreaderitemtemplate"),
								readerWidget = binder({id:"locationdetailreaderitem-"+reader.label, name:reader.name, tor:reader.tor});
							
							readersWidget.append(readerWidget);
							
							xConnect.locationDetails.decorateReader(reader);
														
							xConnect.eventDispatcher.register( reader.name, xConnect.locationDetails.handleReaderEvent );
						});
					},
					decorateReader : function(reader) {
						// set the reader icon img
						var readerWidget = $("#locationdetailreaderitem-" + reader.label);
						
						xConnect.reader.decorator({reader:reader, readerWidget:readerWidget});
						
						// hack to get it to render like the other content
						readerWidget.addClass('ui-li ui-li-static ui-btn-up-a ui-li-has-thumb ui-li-last');
						readerWidget.find('img').addClass('buttonicon ui-li-thumb');
						readerWidget.find('h3').addClass("ui-li-heading");
					},
					setup : function(location) {
						xConnect.locationDetails.setupCallbacks(location);
						xConnect.locationDetails.decorateView(location);
						xConnect.eventDispatcher.register( location.name, xConnect.locationDetails.handleLocationEvent );
					},
					handleReaderEvent : function(e) {
						xConnect.locationDetails.decorateReader(e.message.reader);
					},
					handleLocationEvent : function(e) {
						xConnect.locationDetails.decorateView(e.message.location);
					}
				};

			}());

			// add combined view component to xConnect
			(function () {
				xConnect.combinedView = {
					pageInit : function() {
						$("#invisibleGreeterToggle").on('click', function() {
							xConnect.combinedView.toggleToGreeterView();
						});
						$("#invisibleCombinedToggle").on('click', function() {
							xConnect.greeterView.toggleToCombinedView();
						});						
						//xConnect.combinedView.setVenue();
						xConnect.data.showVenue();
						$('#combinedViewCastAction').on('click', xConnect.utilities.castAction);
					},
					setup : function() {
						$(".castLabel").text(xConnect.data.user.id.portalId);
						xConnect.combinedView.loadLocations();
					},
					toggleToGreeterView : function() {
						var toggle = $("#combinedGreeterToggle");
						
						// switch icon
						toggle.css({'background-position': '77px'});
						$("#greeterview [data-role='header']").append(toggle);
						$.mobile.changePage("#greeterview", {transition:'none'});
					},
					showVenue : function() {
						var nameWidget = $("#combinedView .venueName");
						nameWidget.text(xConnect.data.venue);
					},
					decorateLocation : function(location) {
						var locationWidget = $("#combinedView-" + location.label),
							locationNameWidget = locationWidget.find("[data-bind='location']"),
							castWidget = locationWidget.find('[data-bind="cast"]'),
							castText = location.cast ? location.cast.portalId : location.stateName;
						
						locationNameWidget.text(location.name);
						castWidget.text(castText);
						
						if( castText == 'closed' ) {
							locationWidget.find('.cast').addClass('closed');
						} else {
							locationWidget.find('.cast').removeClass('closed');
						}
					},
					decorateReader : function(reader) {
						var readerWidget = $("#combinedView-" + reader.label);
						
						xConnect.reader.decorator({reader:reader,readerWidget:readerWidget});
					},
					loadLocations : function () {
						var listDiv = $("#combinedviewlist"),
							listControl = $(document.createElement('ul')),
							locationList = xConnect.data.locations.list,
							locationHeader = {},
							headerBinder = xConnect.binder("#combinedviewheadertemplate"),
							itemBinder = xConnect.binder("#combinedviewitemtemplate"),
							newReader = {},
							iconName = "",
							castString = "";
						
						// empty the list control if it's not already empty
						listDiv.empty();
						listControl.attr({'data-role':'listview'});
						listControl.addClass('gaList');
						listDiv.append(listControl);

						locationList.forEach( function( locationData ) {
							castString = (locationData.cast ? locationData.cast.portalId : "closed");

							locationHeader = headerBinder({id:"combinedView-" + locationData.label, location:locationData.name, cast: castString});
							listControl.append(locationHeader);
							
							xConnect.combinedView.decorateLocation(locationData);
							
							xConnect.eventDispatcher.register( locationData.name, xConnect.combinedView.handleLocationEvent );
							
							locationData.readers.forEach( function(reader) {
								newReader = itemBinder({name: reader.name, id : "combinedView-" + reader.label});
								listControl.append(newReader);
								
								xConnect.combinedView.decorateReader(reader);
								
								// add the click handler
								newReader.on('click', (function() { // create a closure through an immediate function to capture the current reader
									return function(e) {
										xConnect.readerUtilityPage.selectReader(newReader, reader, locationData);
									}; // end click handler
								}()) // end and invoke immediate function
								);
								
								xConnect.eventDispatcher.register( reader.name, xConnect.combinedView.handleReaderEvent );
							});

						});
						
						try {
							listDiv.trigger("refresh");
							listDiv.trigger("create");
						} catch(e) {
							//ignore failure
						}
					},
					handleLocationEvent : function(e) {
						xConnect.combinedView.decorateLocation(e.message.location);
					},
					handleReaderEvent : function(e) {
						xConnect.combinedView.decorateReader(e.message.reader);
					}
				};

			}());

			// add greeter view component to xConnect
			(function () {
				xConnect.greeterView = {
					greeterList : [],
					pageInit : function() {
						xConnect.greeterView.loadGreeters();
						$(".castLabel").text(xConnect.data.user.id.portalId);
						xConnect.eventDispatcher.register(xConnect.eventDispatcher.greeterStateChangeType, xConnect.greeterView.handleGreeterEvent );
					},
					handleGreeterEvent : function(e) {
						var location = e.message.location,
							greeterName = e.message.greeterName;
						
						// a location in the list has changed state
						if( location.state == "open" && location.cast.portalId == greeterName ) { // add any greeters with newly opened locations
							xConnect.greeterView.addGreeter(greeterName);
						} else { // remove any greeters who no longer have open locations
							// ok, so this greeter just closed a location, but do they have others (ie: are they still associated with a location)?
							var removeGreeter = true;
							
							xConnect.data.locations.list.forEach(function(location){
								if( location.cast && location.cast.portalId == greeterName ) {
									removeGreeter = false;
								}
							});
							
							if( removeGreeter ) {
								xConnect.greeterView.removeGreeter(greeterName);
							}
						}
					},
					toggleToCombinedView : function() {
							var toggle = $("#combinedGreeterToggle");
							
							// switch icon
							toggle.css({'background-position': '0px'});
							$("#combinedView [data-role='header']").append(toggle);
							$.mobile.changePage("#combinedView", {transition:'none'});
						},
					decorateGreeter : function(greeter) {
						var greeterWidget = $("#greeterview-" + greeter.replace(/[^a-z0-9]/gi,"_") );
						
						// set image source
						greeterWidget.find('img').attr( 'src', "img/greeter-icon.png");
					},
					addGreeter : function(greeterName) {
						var newGreeter = {},
							listDiv = $("#greeterviewlist"),
							listControl = listDiv.find('ul'),
							greeterList = xConnect.greeterView.greeterList,
							itemBinder = xConnect.binder("#greeterviewitemtemplate"),
							greeterIndex = 0,
							greeterAlreadyAdded = false;
						
						for(greeterIndex = 0; greeterIndex < greeterList.length; greeterIndex++ ) {
							if(greeterList[greeterIndex] == greeterName ){
								greeterAlreadyAdded = true;
								break;
							}
						}

						if( !greeterAlreadyAdded ) { // if it's not already in the list
							newGreeter = itemBinder({name: greeterName, id : "greeterview-" + greeterName.replace(/[^a-z0-9]/gi,"_")});
							
							greeterList.push(greeterName);
							listControl.append(newGreeter);
							
							xConnect.greeterView.decorateGreeter(greeterName);
							
							// add the click handler
							// create a closure through an immediate function to capture the current greeter
							newGreeter.on('click', (function() { 
								return function(e) {
									xConnect.greeterUtilityPage.selectGreeter(greeterName);
								}; // end click handler
							}())); // end and invoke immediate function
						}
					},
					removeGreeter : function(greeterName) {
						var greeterWidget = $('#greeterview-'+greeterName.replace(/[^a-z0-9]/gi,"_")),
							listDiv = $("#greeterviewlist"),
							listControl = listDiv.find('ul'),
							greeterList = xConnect.greeterView.greeterList,
							greeterIndex = 0,
							greeterIsInList = false;
						
						for(greeterIndex = 0; greeterIndex < greeterList.length; greeterIndex++ ) {
							if(greeterList[greeterIndex] == greeterName ){
								greeterIsInList = true;
								break;
							}
						}
						
						
						if( greeterIsInList ) { // if it's in the list
							if( greeterWidget ) { // can this ever not be valid??
								greeterWidget.remove();
							}
							
							greeterList.splice(greeterIndex, 1);
						}
					},
					loadGreeters: function () {
						var listDiv = $("#greeterviewlist"),
							listControl = $(document.createElement('ul')),
							locationList = xConnect.data.locations.list,
							greeterList = xConnect.greeterView.greeterList,
							greeterName = "";
						
						greeterList.length = 0;
						
						// empty the list control
						listDiv.empty();
						listControl.attr({'data-role':'listview'});
						listControl.addClass('ui-listview gaList');
						listDiv.append(listControl);
						
						// create greeter list of all greeters with open locations
						locationList.forEach(function(locationData){
							if( locationData.state == "open" ) {
								if( locationData.cast ) {
									greeterName = locationData.cast.portalId;
									xConnect.greeterView.addGreeter(greeterName);
								} else {
									console.log("Open location with no cast: "+ locationData.name);
								}
							}
						});
					}
				};

			}());

			// add utility function component to xConnect
			(function () {
				xConnect.utilities = {
					showingCastActions : false,
					ajax : function(xbrc, urlString, request, success, error) {
						$.mobile.loading('show');
						urlString += "?random="+Math.random();
						$.ajax( urlString , {
							timeout : xConnect.data.ajaxTimeout,
							dataType : "json",
							type : "POST",
							data : JSON.stringify(request),
							success : function(data, textStatus, jqXHR){
								var wasError = false,
									errorMessage = "";
								
								$.mobile.loading('hide');
								
								// only call the success function if there was a successful result
								if( data.type == "processingError" ) { // the request failed on the xbrc
                                    errorMessage = data.errorDescription;
									wasError = true;
								} else if(data.type) { // if it looks like a valid message (ie: has a type but wasn't ane error type)...
									success(data, textStatus, jqXHR);
								} else {
									errorMessage = "Empty response from server";
									wasError = true;
								}
								
								if( wasError ) {
									xConnect.utilities.ajaxError(errorMessage, jqXHR);
								}
							},
							error : error || (function() {
								return function(jqXHR, textStatus, errorThrown) {
									$.mobile.loading('hide');
									xConnect.utilities.ajaxError(textStatus, jqXHR);
									xConnect.data.xbrcs.actions.wentOffline(xbrc);
								};
							}())
						});
					},
					ajaxError : function( message, jqXHR ) {
						//console.log("error:"+textStatus+"\n");
						console.log("status:"+jqXHR.status+"\n");
						console.log("statusText:"+jqXHR.statusText+"\n");
						
						xConnect.utilities.errorNotificationPageInit("Network Error", message );
						xConnect.utilities.showNotificationPage();
					},
                    isPhoneGap : function() {
                        return navigator.userAgent.match(/(iPhone|iPod|iPad|Android|BlackBerry)/);
                    },
                    isConnected : function() {
                        // We currently always assume we're connected if we're in a web browser.
                        // Makes it tougher to debug...but...
                        var connected = true;

                        if ( xConnect.utilities.isPhoneGap() ) {
                            var networkState = navigator.connection.type;
                            console.log("Network type: " + networkState);

                            // Need to check the network state against known types.
                            if ( networkState == "none") {
                                connected = false;
                            }
                        }

                        return connected;
                    },
					generateClientReference : function() {
						return xConnect.data.user.id.portalId + ":" + xConnect.data.deviceId;
					},
					saveVenueToSettings : function() {
						xConnect.cordovaPlugins.Settings.setVenue(xConnect.data.venue);
					},
					selectors : {
						values : { 
							coordinatorModeSelector : 'Coordinator',
							venueSelector : "Magic Kingdom"
						},
						callbacks : {
							
						}
					},
					decorateSelectors : function() {
						var selectors = $('.gaSelector');
						selectors.each(function(){
							xConnect.utilities.decorateSelector($(this));
						});
					},
					decorateSelector : function(selector) {
						var selectorId = selector.attr('id'),
							allButtonsInGroup = selector.find('.gaSelectorButton'),
							allIconsInGroup = selector.find('.gaSelectorIcon'),
							currentValue = xConnect.utilities.selectors.values[selectorId];
						
						allIconsInGroup.css({'background-position-x':'0px'});
						
						if( currentValue ) { // if there is a default value
							allButtonsInGroup.each(function(){
								var radioButton = $(this),
									radioValue = radioButton.find(".gaSelectorText").text(),
									radioIcon = radioButton.find('.gaSelectorIcon');
								if(radioValue == currentValue){
									radioIcon.css({'background-position-x':'25px'});
								}
							});
						}
					},
					actingAsGreeter : function() {
						// am I a greeter or a coordinator acting as a greeter?
						var result = false;
								
						if( xConnect.data.user.role == xConnect.data.greeterRoleString || xConnect.utilities.selectors.values.coordinatorModeSelector == "Greeter" ) {
							result = true;
						}
						
						return result;
					},
					appInit : function( callback ) {
						window.onerror = function( msg, url, line ) {
							xConnect.utilities.errorNotificationPageInit("Application Error", msg + " : " + line );
							xConnect.utilities.showNotificationPage();
						};
						
						xConnect.data.setGUID();

						$('#notificationGotItButton').on('click',xConnect.utilities.hideNotificationPage );

						$(".utility").on('click', function(e) {
							var utilityElement = $(e.target).closest("*[data-xconnect-utility]"),
								utilityFunction = utilityElement.attr("data-xconnect-utility");
							
							xConnect.currentUtilityPage.actions[utilityFunction+"Setup"]();
						});
						
						xConnect.utilities.decorateSelectors();
						
						$(".gaSelectorButton").on('click', function(e) {
							var target = $(e.currentTarget),
								selector = target.parent(),
								selectorId = selector.attr('id'),
								radioValue = target.find(".gaSelectorText").text();
							
							if( xConnect.utilities.selectors.values[selectorId] != radioValue ) { // has the value changed?
								xConnect.utilities.selectors.values[selectorId] = radioValue; // set the value
								if(xConnect.utilities.selectors.callbacks[selectorId]) { // call the handler
									xConnect.utilities.selectors.callbacks[selectorId]();
								}
							}
							
							xConnect.utilities.decorateSelector(selector);
						});
						
                        console.log('Loading plugins...');
						xConnect.cordovaPlugins = {
								MacAddress : {
									getMac : function(callback) {
									
										cordova.exec(callback, function(err) {
											console.log('mac failed: '+ err);
										}, "MacAddress", "getMac", []);
									}
								},
								dnsQuery : {
									srv : function(service, protocol, domain, callback) {  // srv = <service>, <protocol>, <domain>
									
										cordova.exec(callback, function(err) {
											console.log("dnsQuery failed");
											console.log('Error: '+ err);
										}, "DNSQuery", "srv", [service, protocol, domain]);
									},
                                    ping : function(callback) {

                                        cordova.exec(callback, function(err) {
                                            console.log("ping failed");
                                        }, "DNSQuery", "ping", []);
                                    }
								},
								Settings : {
									getMode : function(callback) {
										cordova.exec(callback, function(err) {
											console.log("getMode failed: " + err);
										}, "Settings", "getMode", []);
									},
									getVenue : function(callback) {
										cordova.exec(callback, function(err) {
											console.log("getVenue failed: " + err);
										}, "Settings", "getVenue", []);
									},
									getXbrms : function(callback) {
										cordova.exec(callback, function(err) {
											console.log("getXbrms failed: " + err);
										}, "Settings", "getXbrms", []);
									},
                                    getXbrcs : function(callback) {
                                        cordova.exec(callback, function(err) {
                                            console.log("getXbrcs failed: " + err);
                                        }, "Settings", "getXbrcs", []);
                                    },
									getUserRegistry : function(callback) {
										cordova.exec(callback, function(err) {
											console.log("getUserRegistry failed: " + err);
										}, "Settings", "getUserRegistry", []);
									},
									getUseSSL : function(callback) {
										cordova.exec(callback, function(err) {
											console.log("getUseSSL failed: " + err);
										}, "Settings", "getUseSSL", []);
									},
                                    getAppVersion : function(callback) {
                                        cordova.exec(callback, function(err) {
                                            console.log("getAppVersion failed: " + err);
                                        }, "Settings", "getAppVersion", []);
                                    },
                                    getConnectionCheckInterval : function(callback) {
                                        cordova.exec(callback, function(err) {
                                            console.log("getConnectionCheckInterval failed: " + err);
                                        }, "Settings", "getConnectionCheckInterval", []);
                                    },
                                    getPollingInterval : function(callback) {
                                        cordova.exec(callback, function(err) {
                                            console.log("getPollingInterval failed: " + err);
                                        }, "Settings", "getPollingInterval", []);
                                    },
                                    getXbrcTimeout : function(callback) {
                                        cordova.exec(callback, function(err) {
                                            console.log("getXbrcTimeout failed: " + err);
                                        }, "Settings", "getXbrcTimeout", []);
                                    },
									setVenue : function(venue, callback) { // venue="Magic Kingdom"
										cordova.exec(callback, function(err) {
											console.log("setVenue failed: " + err);
										}, "Settings", "setVenue", [venue]);
									},
									setXbrms : function(xbrms, callback) { // xbrms="http://10.1.1.1:8080"
										cordova.exec(callback, function(err) {
											console.log("setXbrms failed: " + err);
										}, "Settings", "setXbrms", [xbrms]);
									},
                                    setXbrcs : function(xbrc, callback) { // xbrc="http://10.1.1.1:8080"
                                        cordova.exec(callback, function(err) {
                                            console.log("setXbrcs failed: " + err);
                                        }, "Settings", "setXbrcs", [xbrc]);
                                    },
                                    setConnectionCheckInterval : function(interval, callback) {
                                        cordova.exec(callback, function(err) {
                                            console.log("setConnectionCheckInterval failed: " + err);
                                        }, "Settings", "setConnectionCheckInterval", [interval]);
                                    },
                                    setPollingInterval : function(interval, callback) {
                                        cordova.exec(callback, function(err) {
                                            console.log("setPollingInterval failed: " + err);
                                        }, "Settings", "setPollingInterval", [interval]);
                                    },
                                    setXbrcTimeout : function(interval, callback) {
                                        cordova.exec(callback, function(err) {
                                            console.log("setXbrcTimeout failed: " + err);
                                        }, "Settings", "setXbrcTimeout", [interval]);
                                    }
								}
							};

                        xConnect.utilities.castActionInit();

						// this function is asynchronous, so anything that depends on its results has to wait for it to finish
						xConnect.utilities.setMode(callback);

                        // We should never allow less than a second.
                        var connectionCheckInterval = xConnect.utilities.getConnectionCheckInterval();

                        // Always set the timeout at least a half second less then the check interval.
                        var connectionCheckTimeout = connectionCheckInterval - 100;

                        console.log("Heartbeat check interval settings: connectionCheckInterval=" + connectionCheckInterval +
                                ", connectionCheckTimeout:" + connectionCheckTimeout);

                        // Get the subscription interval just to make sure settings are initialized.
                        xConnect.utilities.getPollingInterval();

                        // Start the ping process.
                        setInterval( function() {

                            // Find an xBRC that is available.
                            xConnect.data.xbrclist.forEach(function(xbrc) {
                                var statusxbrc = xbrc.url + "/heartbeat";

                                $.ajax( statusxbrc , {
                                    timeout : connectionCheckTimeout,
                                    type : "GET",
                                    cache: false,
                                    success : function(data, textStatus, jqXHR){
                                        // We are already in retry mode, so let the normal
                                        // retry logic try to reconnect.
                                        console.log("Success talking to heartbeat: " + xbrc.url);

                                        if ( xbrc.isOffline ) {
                                            xConnect.data.xbrcs.actions.wentOnline(xbrc);
                                        }
                                    },
                                    error : function() {
                                        console.log("Error talking to heartbeat: " + xbrc.url);

                                        // Set the xbrc to offine.
                                        xConnect.data.xbrcs.actions.wentOffline(xbrc);
                                    }
                                })
                            });
                        }, connectionCheckInterval);
					},
					errorNotificationPageInit : function(heading, message) {
						var notificationDetails = $('#notificationDetails'),
							header = notificationDetails.find('h1'),
							text = notificationDetails.find('h3');
						
						header.text( heading );
						text.text( message );
					},
					bumpNotificationPageInit : function(location, actionInitiator) {
						var notificationDetails = $('#notificationDetails'),
							header = notificationDetails.find('h1'),
							text = notificationDetails.find('h3');
						
						header.text('Bump Notification');
						text.text( actionInitiator + " bumped you from location " + location.name );
					},
					closeNotificationPageInit : function(location, actionInitiator) {
						var notificationDetails = $('#notificationDetails'),
							header = notificationDetails.find('h1'),
							text = notificationDetails.find('h3');
					
						header.text('Close Notification');
						text.text( actionInitiator + " closed location " + location.name );
					},
					showNotificationPage : function() {
						var darkDiv = $("#darkDiv"),
						notificationDetails = $('#notificationDetails'),
						bodyHeight = window.innerHeight;
						
						darkDiv.css({'display':'block',
							'height':bodyHeight });
						notificationDetails.css({'display':'block'});
					},
					hideNotificationPage : function() {
						var darkDiv = $("#darkDiv"),
						notificationDetails = $('#notificationDetails');
						
						darkDiv.css({'display':'none'});
						notificationDetails.css({'display':'none'});
					},
                    getAppVersion: function () {
                        if ( xConnect.utilities.isPhoneGap() ) {
                            var fullVersion = "v";
                            xConnect.cordovaPlugins.Settings.getAppVersion( function( version ) {
                               fullVersion += version;
                            } );
                            return fullVersion;
                        }
                        else {
                            return "Web";
                        }
                    },
                    getConnectionCheckInterval: function () {
                        var checkInterval = 3000;

                        if ( xConnect.utilities.isPhoneGap() ) {
                            xConnect.cordovaPlugins.Settings.getConnectionCheckInterval( function( interval ) {
                                if ( interval === null || interval.length === 0 ) {
                                    // Assign a default and store to the settings.
                                    console.log("Writing default check interval to settings.");
                                    xConnect.cordovaPlugins.Settings.setConnectionCheckInterval(checkInterval);
                                }
                                else {
                                    checkInterval = parseInt(interval);
                                }
                            });
                        }

                        return checkInterval;
                    },
                    getPollingInterval: function () {
                        var pollingInterval = xConnect.data.normalSubscribeTimeout;

                        if ( xConnect.utilities.isPhoneGap() ) {
                            xConnect.cordovaPlugins.Settings.getPollingInterval( function( interval ) {
                                if ( interval === null || interval.length === 0 ) {
                                    // Assign a default and store to the settings.
                                    console.log("Writing default polling interval to settings.");
                                    xConnect.cordovaPlugins.Settings.setPollingInterval(pollingInterval);
                                }
                                else {
                                    pollingInterval = parseInt(interval);
                                }
                            });
                        }

                        console.log("getPollingInterval: " + pollingInterval);
                        return pollingInterval;
                    },
                    getXbrcTimeout: function () {
                        var xbrcTimeout = xConnect.data.defaultXbrcTimeout;

                        if ( xConnect.utilities.isPhoneGap() ) {
                            xConnect.cordovaPlugins.Settings.getXbrcTimeout( function( interval ) {
                                if ( interval === null || interval.length === 0 ) {
                                    // Assign a default and store to the settings.
                                    console.log("Writing default polling interval to settings.");
                                    xConnect.cordovaPlugins.Settings.setXbrcTimeout(xbrcTimeout);
                                }
                                else {
                                    xbrcTimeout = parseInt(interval);
                                }
                            });
                        }

                        console.log("xbrcTimeout: " + xbrcTimeout);
                        return xbrcTimeout;
                    },
                    castActionInit : function() {
							var body = $('body'),
							bodyHeight = body.css('height'),
							bodyWidth = body.css('width'),
							bodyMarginLeft = body.css('margin-left'),
							bodyMarginRight = body.css('margin-right'),
							bodyHeightAsInt = parseInt(bodyHeight),
							bodyWidthAsInt = parseInt(bodyWidth),
							bodyMarginLeftAsInt = parseInt(bodyMarginLeft),
							bodyMarginRightAsInt = parseInt(bodyMarginRight),
							darkDiv = $('#darkDiv'),
							headerHeight = 42;
						
						darkDiv.css({'width':window.innerWidth + "px"});

						$('#castActionLogoutButton').on('click', xConnect.utilities.logoutCastMember);
						$('#castActionCancelButton').on('click', xConnect.utilities.hideCastActions);
						$('#confirmLogoutButton').on('click', xConnect.utilities.performLogout);
						$('#confirmSwitchButton').on('click', xConnect.loginPage.performPrepForCoordinator);

                        var version = 'xGreeter ' + xConnect.utilities.getAppVersion();
                        $('#appVersion').find('span').text(version);
					},
					castAction : function() {
						if( xConnect.utilities.showingCastActions ) {
							xConnect.utilities.hideCastActions();
						} else {
							xConnect.utilities.showCastActions();
						}
					},
					showCastActions : function() {
						var darkDiv = $("#darkDiv"),
						castActionMenu = $('#castActionMenu'),
						bodyHeight = $('body').css('height'),
						bodyHeightAsInt = parseInt(bodyHeight),
						headerHeight = 42;
						
						darkDiv.css({'display':'block',
							'height':window.innerHeight + "px" });
						castActionMenu.css({'display':'block'});
						xConnect.utilities.showingCastActions = true;
					},
					hideCastActions : function() {
						var darkDiv = $("#darkDiv"),
							castActionMenu = $('#castActionMenu');
						
						darkDiv.css({'display':'none'});
						castActionMenu.css({'display':'none'});
						xConnect.utilities.hideConfirmLogout();
						xConnect.utilities.showingCastActions = false;
					},
					showConfirmLogout : function() {
						var confirmLogoutDiv = $('#confirmLogoutDiv'),
							confirmLogoutButton = $('#confirmLogoutButton'),
							confirmSwitchButton = $('#confirmSwitchButton'),
							logoutButton = $('#logoutButton'),
							list = confirmLogoutDiv.find('ul'),
							li = {};
						
						list.empty();
						xConnect.data.user.myLocations.forEach(function(location){
							li = $(document.createElement('li'));
							list.append(li);
							li.text(location.name);
						});
						logoutButton.css({'display':'none'});
						confirmLogoutButton.css({'display':'block'});
						confirmSwitchButton.css({'display':'none'});
						confirmLogoutDiv.css({'display':'block'});
					},
					showConfirmSwitchMode : function() {
						var confirmLogoutDiv = $('#confirmLogoutDiv'),
							confirmLogoutButton = $('#confirmLogoutButton'),
							confirmSwitchButton = $('#confirmSwitchButton'),
							logoutButton = $('#logoutButton'),
							list = confirmLogoutDiv.find('ul'),
							li = {};
						
						list.empty();
						xConnect.data.user.myLocations.forEach(function(location){
							li = $(document.createElement('li'));
							list.append(li);
							li.text(location.name);
						});
						logoutButton.css({'display':'none'});
						confirmLogoutButton.css({'display':'none'});
						confirmSwitchButton.css({'display':'block'});
						confirmLogoutDiv.css({'display':'block'});
					},
					hideConfirmLogout : function() {
						var confirmLogoutDiv = $('#confirmLogoutDiv'),
							logoutButton = $('#logoutButton');
						
						logoutButton.css({'display':'block'});
						confirmLogoutDiv.css({'display':'none'});
					},
					logoutCastMember : function() {
						if( xConnect.data.user.myLocations.length > 0 ) {
							// confirm close before loging out
							xConnect.utilities.showConfirmLogout();
						} else {
							xConnect.utilities.performLogout();
						}
					},
					performLogout : function() {
						xConnect.data.user.myLocations.forEach(function(location){
							xConnect.data.locations.actions.closeLocation(location);
						});
						xConnect.data.user.myLocations.length = 0;
						xConnect.data.user.actions.resetUser();
						history.length = 0;
						xConnect.utilities.hideCastActions();
						$.mobile.changePage('#loginPage');
					},
                    validateCredentialsHelper : function(userName, auth, url1, url2, callback)
                    {             
                        console.log("Authenticating using: " + url1);
                        
                        $.ajax( url1, {
                            timeout : 5000,
                            dataType : "json",
                            headers : { "Authorization" : auth},
                               
                            success : (function() {
                                return function(data, textStatus, jqXHR)
                                {
                                    if( data.authenticated )
                                    {
                                        console.log("login success");
                                        xConnect.data.user.id.portalId = userName;
                                        xConnect.data.user.role = "";
                                        data.roles.forEach(function(role)
                                        {
                                            if(role == xConnect.data.greeterRoleString && xConnect.data.user.role == "" )
                                            {
                                                xConnect.data.user.role = xConnect.data.greeterRoleString;
                                            }
                                            if(role == xConnect.data.coordinatorRoleString )
                                            {
                                                xConnect.data.user.role = xConnect.data.coordinatorRoleString;
                                            }
                                        });
                                        if( xConnect.data.user.role == "" )
                                        {
                                            xConnect.data.user.role = xConnect.data.greeterRoleString;
                                        }
                                        callback(true);
                                    }
                                    else
                                    {
                                        console.log("Received malformed response data from authentication call!");
                                        console.log("Verify access to URL: " + urlString);
                                        callback(false);
                                    }
                               }
                            }()),
                            error : (function() {
                                return function(response, errortype)
                                {
                                    if (response.status == 401)
                                    {
                                        console.log("Authentication failed (due to bad creds or invalid endpoint)");
                                        callback(false);
                                    }
                                    else
                                    {
                                        if (errortype == 'timeout')
                                        {
                                            console.log("Call to authentication URL timed out");
                                        }
                                        else
                                        {
                                            console.log("Call to authentication URL failed (" + response + "), errortype: " + errortype);
                                        }
                                     
                                        if (url2)
                                        {
                                            console.log("Switching to alternate authentication gateway host service");
                                            xConnect.utilities.validateCredentialsHelper(userName, auth, url2, null, callback);
                                            
                                         } else {
                                            console.log("Returning with failure, no alternate authentication gateway servers to call");
                                            callback(false);
                                         }
                                    }
                                }
                            }())
                        });
                    },
					validateCredentials : function(userName, password, callback)
                    {
						function make_base_auth(user, password)
                        {
							  var tok = user + ':' + password;
							  var hash = btoa(tok);
							  return "Basic " + hash;
						}
						
						if( xConnect.data.xbrclist.length > 0 ||
                            xConnect.data.xbrmslist.length > 0) // do we have any xBRC's or xBRMS's?
                        {
							var userDir = xConnect.data.userRegistry ? xConnect.data.userRegistry + "\\" : "",
								auth = make_base_auth(userDir + userName, password),
                                currentXbrms = (xConnect.data.xbrmslist.length > 0) ? xConnect.data.xbrmslist[0] : "",
                                xbrcUrl = (xConnect.data.xbrclist.length > 0) ? xConnect.data.xbrclist[0].url : "",
								authPort = xConnect.data.useSSLForAuth ? xConnect.data.sslAuthenticationPort : xConnect.data.authenticationPort,
                                xbrcUrl = (xbrcUrl != "") ? xbrcUrl.replace(xConnect.data.xbrcPort, authPort) : "",
                                urlxBRCString = (xbrcUrl != "") ? xbrcUrl + xConnect.data.xBRCAuthenticationUrl : null,
                                urlxBRMSString = (currentXbrms != "") ? "http://" + currentXbrms.host + ":" + currentXbrms.port + xConnect.data.xBRMSAuthenticationUrl : null;
								
                            console.log("currentXbrms: " + currentXbrms);
                            console.log("xbrcUrl: " + xbrcUrl);
                            console.log("authPort: " + authPort);
                            console.log("urlxBRCString: " + urlxBRCString);
                            console.log("urlxBRMSString: " + urlxBRMSString);
             
							if( xConnect.data.useSSLForAuth )
                            {
								urlxBRCString = urlxBRCString.replace( "http", "https" );
                                // It is not clear if this is to be used? And on what port?
                                // urlxBRMSString = urlxBRMSString.replace( "http", "https" );
							}
             
                            if (urlxBRMSString)
                            {
                                xConnect.utilities.validateCredentialsHelper(userName, auth, urlxBRMSString, urlxBRCString, callback);
                            }
                            else
                            {
                                xConnect.utilities.validateCredentialsHelper(userName, auth, urlxBRCString, null, callback);
                            }
						}
                        else
                        {
							callback(false);
						}
					},
					populateMyLocations : function() {
						var locationList = xConnect.data.locations.list,
							myLocations = xConnect.data.user.myLocations,
							myLocationNames = [],
							hasChanged = false;
						
						myLocations.forEach(function(location) {
							myLocationNames.push(location.name);
						});
					
						// add any items to our selected location list if we're marked as owning them
						myLocations.length = 0;
						locationList.forEach(function(location) {
							if( location.cast && location.cast.portalId == xConnect.data.user.id.portalId ) {
								myLocations.push(location);
							}
                        });
						
						if( myLocationNames.length != myLocations.length ) {
							hasChanged = true;
						} else {
							for(var i = 0; i < myLocationNames.length; i++ ) {
								if( myLocationNames[i] != myLocations[i].name ) {
									hasChanged = true;
									break;
								}
							};
						}
						
						if( hasChanged ) {
							xConnect.eventDispatcher.dispatch({name:xConnect.eventDispatcher.myLocationsType});
						}
					},
					dispatch : function (messageList) {
						messageList.forEach(function(message) {
							xConnect.eventDispatcher.dispatch({message:message, name:message.type});
						});
					},
					getReaderIconName : function(reader) {
						var iconName = "",
							readerLights = reader.lights,
							readerState = reader.state;
						
						if( readerState == "open" ) {
							iconName = xConnect.data.readerIconNames[readerLights];
						} else {
							iconName = xConnect.data.readerIconNames[readerState];
						}
						
						return iconName;
					},
					getQueryObject : function() {
						var queryStrings = {}, 
							hash,
							q = document.URL.split('?')[1];
						
					    if(q != undefined){
					        q = q.split('&');
					        for(var i = 0; i < q.length; i++){
					            hash = q[i].split('=');
					            queryStrings[hash[0]] = hash[1];
					        }
						}
					    
					    return queryStrings;
					},
					setMode : function ( callback ) {
						var queryObject = xConnect.utilities.getQueryObject(),
							needToImportStrategy = false;

						xConnect.data.mode = "Normal";
						if( queryObject.mode ) {
							// mode was specified in the url
							xConnect.data.mode = queryObject.mode;
							needToImportStrategy = true;
						} else {
							// determine the mode
							if( typeof cordova != "undefined" ) {  // we're running in phonegap
								xConnect.cordovaPlugins.Settings.getMode((function(){ // need to capture callback in a closure
									return function(result){
										if( result == "Failover" ) {
											xConnect.data.mode = "Failover";
										} else if( result == "Demo" ) {
											xConnect.data.mode = "Demo";
										}
										
										xConnect.utilities.importStrategy(callback);
									};
								}()));
							
								// don't set needToImportStrategy because we'll call that when phonegap gets back to us
								
							} else {
								xConnect.data.mode = "Demo";
								needToImportStrategy = true;
							}
						}
						
						if( needToImportStrategy ) {
							xConnect.utilities.importStrategy(callback);
						}
					},
					setDeviceId : function(callback) {
						xConnect.cordovaPlugins.MacAddress.getMac((function(){
							return function(mac){
								xConnect.data.deviceId = mac;
								callback();
							};
						}()));
					},
					setUserRegistryFromCache : function(callback) {
						xConnect.cordovaPlugins.Settings.getUserRegistry((function(){
							return function(userRegistry){
								xConnect.data.userRegistry = userRegistry;
								callback();
							};
						}()));
					},
					importStrategy : function(callback) {
						var needToCallback = true;
						
						console.log(xConnect.data.mode + " mode");

						if( xConnect.data.mode != "Normal" ) {
							// save the calling back until the async "getStript" returns
							needToCallback = false;
							// load the script for the other modes
							$.getScript("js/" + xConnect.data.mode + ".js", (function(){ // need to capture callback in a closure
								return function() {
									// the mode script will add features to the xConnect.utilities.strategies object
									
									// override methods base on strategies for different modes of operation Normal/Failover/Demo
									for( var member in xConnect.utilities.strategies[xConnect.data.mode] ) {
										// save the normal mode version, in case we want to use it from the override
										if(xConnect.utilities[member]) {
											xConnect.utilities.strategies["Normal"][member] = xConnect.utilities[member];
										}
										xConnect.utilities[member] = xConnect.utilities.strategies[xConnect.data.mode][member];
									}
									callback();
								};
							}()));
						}
						if( needToCallback ) {
							callback();
						}
					},
					disableLink : function ( link ) {
						link.addClass("ui-disabled");
					},
					enableLink : function ( link ) {
						link.removeClass("ui-disabled");
					},
					setVenueFromCache : function (callback) {
						// fetch venu from settings
						xConnect.cordovaPlugins.Settings.getVenue((function(){
							return function(venue){
								xConnect.data.setVenue(venue);

								if( callback ) {
									callback();
								}
							};
						}()));
					},
					setXbrcFromCache : function (callback) {
                        xConnect.cordovaPlugins.Settings.getXbrcs(function(xbrcs) {
                            $.each(xbrcs, function(index, value) {
                                console.log("Adding xBRC from cached settings:" + value);
                                xConnect.data.xbrclist.push({url:value});
                            });
                        
                            if ( xbrcs.length == 0 ) {
								console.log("Failover mode: no xbrc in settings");
                                xConnect.utilities.errorNotificationPageInit("Configuration Error", "Please confirm a valid xBRC list in the xGreeter settings" );
                                xConnect.utilities.showNotificationPage();
                            }

                            callback();
                        });
					},
					strategies : {
						Normal : {
							// a place to park the normal functionality
						},
						Demo : {
							// loaded on demand in setMode
						},
						Failover : {
							// loaded on demand in setMode
						}
					},
					resynchWithXbrcs : function () {
						var request = { version : "1.0",
								type : "locationStatus",
								clientReference : xConnect.utilities.generateClientReference(),
								sessionId : xConnect.data.GUID 
							},
							urlString = "";
						
						xConnect.data.xbrclist.forEach( function(xbrc){
							
							urlString = xbrc.url + xConnect.data.xbrcMessageUrl + "?random=" + Math.random();

                            //TODO: Need to quiet the error dialog.
							xConnect.utilities.ajax( xbrc, urlString, request, (function(){
									return function(data, textStatus, jqXHR){
										var locationMessages = [],
											locationMessage = {};

										if( data.locations ) {
											data.locations.forEach(function(location){
												locationMessage = {
													"version":"1.0",
													"type":"locationStateChange",
													"location": location
												};
												if( !locationMessage.location.cast ) {
													locationMessage.location.byWhom = {portalId:"The System"};
												}
												locationMessages.push(locationMessage);	
											});
											xConnect.utilities.dispatch(locationMessages);										
										}
									};
							}()),
                            (function(){
                                return function(data, textStatus, jqXHR) {

                                }
                            }));
						});
					},
					subscribeToEvents : function() {
						xConnect.data.subscribeTimeout = xConnect.data.normalSubscribeTimeout;
						
						xConnect.data.xbrclist.forEach(function(xbrc) {
							xConnect.utilities.subscribeToEventsForXbrc(xbrc);
						});
					},
					subscribeToEventsForXbrc : function(xbrc) {
						// {"version":"1.0","type":"requestNotifications","clientReference":"77777777","locations":[{"name":"MK1-Left"}, {"name":"MK4-Right"}],
						// "sessionId":"95DB6F5A-17F6-11E2-BF6A-980B6188709B"}
				

						if( xbrc.jqxhr ) {
							// we already have a request out to that xbrc, so just return
							console.log("Ignoring subscription request because we're already subscribed to " + xbrc.url );
							return;
						}

						
						var request = { version : "1.0",
								type : "requestNotifications",
								clientReference : xConnect.utilities.generateClientReference(),
								locations : ["*"],
								sessionId : xConnect.data.GUID
							},
							urlString = "",
							myLocationNames = [];
						
						if( xConnect.utilities.actingAsGreeter() ) {
							xConnect.data.user.myLocations.forEach(function(location) {
								if( location.xbrc.url == xbrc.url ) {
									myLocationNames.push(location.name);
								}
							});
							request.locations = myLocationNames;
						}

                        if (!xbrc.isOffline) {
                            // add random to prevent caching on ios6
                            urlString = xbrc.url+ xConnect.data.xbrcSubscribeUrl+"?random="+Math.random();
                            console.log("Connecting to: " + urlString);

                            xbrc.jqxhr = $.ajax( urlString , {
                                timeout : xConnect.utilities.getPollingInterval(),
                                dataType : "json",
                                type : "POST",
                                data : JSON.stringify(request),
                                success : (function() {
                                    return function(data, textStatus, jqXHR){
                                    if( xbrc.isOffline ) {
                                        xConnect.data.xbrcs.actions.wentOnline(xbrc);
                                    }
                                    if( data ) {
                                        xConnect.utilities.dispatch(data);
                                    }
                                    setTimeout((function() {
                                        return function() {
                                            if(!xbrc.jqxhr) {
                                                xConnect.utilities.subscribeToEventsForXbrc(xbrc);
                                            }
                                        };
                                    }()),0);
                                };}()),
                                error : (function() {
                                    return function(jqXHR, textStatus, errorThrown) {
                                    if(textStatus == "abort" ) { // we aborted the call ... end of processing
                                        // nothing to do here
                                    } else if(textStatus == "timeout" ) {
                                        setTimeout((function() {
                                            return function() {
                                                if(!xbrc.jqxhr) {
                                                    xConnect.utilities.subscribeToEventsForXbrc(xbrc);
                                                }
                                            };
                                        }()),0);
                                        if( xbrc.isOffline ) {
                                            xConnect.data.xbrcs.actions.wentOnline(xbrc);
                                        }
                                    } else {
                                        console.log("error:"+textStatus+"\n");
                                        console.log("status:"+jqXHR.status+"\n");
                                        console.log("statusText:"+jqXHR.statusText+"\n");
                                        setTimeout((function() {
                                            return function() {
                                                if(!xbrc.jqxhr) {
                                                    xConnect.utilities.subscribeToEventsForXbrc(xbrc);
                                                }
                                            };
                                        }()),xConnect.data.subscribeErrorTimeout );

                                        xConnect.data.xbrcs.actions.wentOffline(xbrc);
                                    }
                                };}()),
                                complete : (function() {
                                    return function () {
                                        delete xbrc.jqxhr;
                                    };
                                }())
                            });
                        }
					},
					copyReaderData : function( reader, myReader ) {
						// create a new attribute "label" for the reader with only alphanumerics
						myReader.label = reader.name.replace(/[^a-z0-9]/gi,"_");

						for( var member in reader ) {
							if( member != "name" ) {
								myReader[member] = reader[member];
							}
						}
					},
					copyLocationData : function( location, myLocation ) {
						// create a new attribute "label" for the location
						myLocation.label = location.name.replace(/[^a-z0-9]/gi,"_");
						
						for( var member in location ) {
							
							if( member == "byWhom" ) { // translate "byWhom" to "cast"
								myLocation["cast"] = location[member];
							} else if( member == "readers" ) { // Just update the readersif they exist, don't blast them away (references will break)
								location.readers.forEach( function(reader){
									var myReader;
									if( myLocation.readers ) {
										myReader = xConnect.data.locations.actions.findReaderInLocation(myLocation, reader.name);	
									} else {
										myLocation.readers = [];
									}
									if(!myReader) { // if the reader wasn't defined ... create it
										myReader = {name:reader.name};
										myLocation.readers.push(myReader);
									}
									xConnect.utilities.copyReaderData(reader, myReader);
								});							
								
								if( myLocation.readers.length != location.readers.length ) {
									// there is a discrepancy between what readers we think are in the location and what xBRC thinks ...
								}
							
								// sort the readers
								myLocation.readers.sort(function(a,b){
									return xConnect.data.locations.actions.compareReaders(a.name, b.name);
								});

							} else {
								myLocation[member] = location[member];
							}

						}
						xConnect.utilities.rollupLocationState(myLocation);
						if( myLocation.state == 'open' && myLocation.cast == undefined ) {
							myLocation.cast = {portalId : "unknown" };
						}
					},
					rollupLocationState : function(location) {
						// roll up the reader state into the location state
						/*
						Location state is just a rollup of the state of the readers they contain even though some 
						actions only work at the aggregate location abstraction. The rollup rules are as follows. 
						If any of the readers in the location are "flashing", the location is "flashing". If any of the 
						readers are "open" (and none are flashing) the location is "open". If no readers are "open" or 
						"flashing" and at least one is "closed" the location is "closed" if all readers are "shutdown" 
						the location is "shutdown".
						*/
						
						if( xConnect.utilities.anyReaders("flashing", location ) ) {
							// if any readers are flashing, the location is flashing
							location.state = "flashing";
							location.stateName = "Flashing";
						} else if( xConnect.utilities.anyReaders( "open", location )) {
							// if any readers are open and none flashing, the location is open
							location.state = "open";
							location.stateName = "Open";
						} else if( xConnect.utilities.anyReaders( "closed", location )) {
							// if any readers are closed and none are flashing or open, the location is closed
							location.state = "closed";
							location.stateName = "Closed";
							// if no readers are open there should be no cast
							delete location.cast;
						} else {
							// otherwise the location is shutdown
							location.state = "shutdown";
							location.stateName = "Out of Service";
							// if no readers are open there should be no cast
							delete location.cast;
						}
					},
					anyReaders : function(state, location) {
						var result = false;
						
						location.readers.forEach( function(reader) {
							if(reader.state == state ) {
								result = true;
							}
						});
						
						return result;
					},
					venueFromCode : function(code) {
						var venue = "";
						
						for( var member in xConnect.data.venueToCode ) {
							if( xConnect.data.venueToCode[member] == code ) {
								venue = member;
							}
						}
						
						return venue;
					},
					initializeVenueMap : function() {
						var imageElement = $('#venueMapImage'),
							imageSrc = xConnect.data.venueMapBase + 'venue-' + xConnect.data.venueCode + ".png";

                        console.log("Venue image: " + imageSrc);
						imageElement.attr( 'src', imageSrc );
                        imageElement.attr('style', '-webkit-transform:translate3d(0,0,0)');
					},
					initializeAppData : function () {
						// Normal mode implementation
						
						// set device Id
						xConnect.utilities.setDeviceId( function() {
							// fetch venueCode from settings
							xConnect.utilities.setVenueFromCache( function() {
								// See if we need a directory / user registry prefix on our user name
								xConnect.utilities.setUserRegistryFromCache( function() {
									// ok, now go and load up all the xbrms, xbrc, and location information
									xConnect.utilities.locateXBRMS();
									
									xConnect.cordovaPlugins.Settings.getUseSSL( function(result){
										if( result == "Yes" ) {
											console.log("Using SSL for Auth");
											xConnect.data.useSSLForAuth = true;
										} else {
											console.log("Not using SSL for Auth");
											xConnect.data.useSSLForAuth = false;
										}
									});

								})
							});
						});
					},
					locateXBRMS : function() {
						var xbrms = {},
						urlString = "",
						xbrmsString = xConnect.data.venueCode + "-xbrms",
						queryObject = xConnect.utilities.getQueryObject();
						
						xConnect.cordovaPlugins.dnsQuery.srv("rest","tcp." + xbrmsString, "", function(result){
							if( result && result.length ) {
							
								result.forEach( function(srvItem){
									console.log("priority = "+srvItem.priority+", weight = "+srvItem.weight + ", port = " + srvItem.port + ", host = " + srvItem.host);
								})
								
								// sort the list of xbrms records by priority then weight
								result.sort(function(a,b){
									if(a.priority < b.priority) {
										return -1;
									} else if( a.priority > b.priority ) {
										return 1;
									} else {
										if( a.weight > b.weight ) {
											return -1;
										} else { // ignore case of equal priority and equal weight
											return 1;
										}
									}
								});
								
								result.forEach( function(srvItem){
									console.log("priority = "+srvItem.priority+", weight = "+srvItem.weight + ", port = " + srvItem.port + ", host = " + srvItem.host);
								})
								
								// save a copy of the xbrms srv records
								xConnect.data.xbrmslist = result.slice(0);
								xConnect.utilities.locateXBRCs();
							} else {
								console.log("XBRMS access failed ... switching to Failover Mode.");
								
								xConnect.utilities.errorNotificationPageInit("Configuration Error", "XBRMS configuration error ... failing over to cached settings" );
								xConnect.utilities.showNotificationPage();
								xConnect.utilities.setXbrcFromCache(function(){
									xConnect.utilities.subscribeToEvents();									
								});
							}
						});
					},
					locateXBRCs : function() {
								
						// use the highest priority/weight for our xbrms connection
						var xbrms = xConnect.data.xbrmslist[0],
							urlString = "http://" + xbrms.host + ":" + xbrms.port + xConnect.data.xbrmsFacilitiesURL;
							
						// 172.16.165.152
						console.log("connecting to xBRMS: " + urlString + "\n");
						$.ajax( urlString , {
							timeout : xConnect.utilities.getXbrcTimeout(),
							dataType : "json",
							success : function(data, textStatus, jqXHR){
								var xbrcIndex = 1,
									xbrcCount = 0;
							
								if( data.facilities && data.facilities.length > 0 ) {
									console.log("success\n");
									for( var key in data ) {
										console.log(key+":"+data[key]+"\n");
									}
									xConnect.data.xbrclist.discoveryAborted = false;
									data.facilities.forEach(function(facility){
										
										console.log("\nfacility: "+facility.name+" - "+facility.model+" - " + facility.haStatus);
										
										if( facility.model !== undefined &&
                                                facility.model.indexOf( xConnect.data.parkEntryModelString ) !== -1 ) {
                                            console.log(facility.name + " checking for solo or master.");
											
											xConnect.utilities.isSoloOrMaster(facility, function() { // callback gets called when the facility is either solo or master
												console.log(facility.name + " is a solo or master.");

                                                xConnect.utilities.convertURLtoVIP(facility, function() { // the callback gets called once the url is a vip.
													console.log(facility.name + " converting URL to VIP.");

                                                    if( !xConnect.data.xbrclist.discoveryAborted ) {
														var alreadyInList = false;
														
														xConnect.data.xbrclist.forEach(function(xbrc) {
															if( xbrc.url == facility.url ) {
                                                                console.log(facility.name + " being dumped. Already in list.");
																alreadyInList = true;
															}
														});
														if( !alreadyInList ) {
                                                            console.log(facility.name + " is subscription source.");
															xConnect.utilities.subscribeToEventsForXbrc(facility);
															
															// add the entry model xBRC to our list of xBRC's
															xConnect.data.xbrclist.push(facility);
															
															for( var fkey in facility ) {
																console.log(fkey+":"+facility[fkey]+"\n");
															}
														} else {
															console.log("Error: more than one xbrc with the same URL");
														}
													}
												});
											});
										}
									});
								} else {
									xConnect.utilities.errorNotificationPageInit("Server Error", "Management service returned no XBRCs ... failing over to cached settings" );
									xConnect.utilities.showNotificationPage();
								}
								
								setTimeout( function() { // if we still have no xbrc's after 5 seconds ... something's up ... switch to cached values.
									if( xConnect.data.xbrclist.length == 0 ) { // if we didn't find any xbrc's look in the settings
										console.log("We didn't find any xBRC's from xBRMS getting from settings");
										xConnect.data.xbrclist.discoveryAborted = true;
										xConnect.utilities.setXbrcFromCache(function(){
											xConnect.utilities.subscribeToEvents();									
										});
									} else {
										console.log("Success with XBRMS ... saving xbrcs to app settings");
										xConnect.utilities.saveXbrcsToSettings();
									}
								}, 5000 );
							},
							error : function(jqXHR, textStatus, errorThrown) {
								xConnect.utilities.ajaxError("Could not connect to the management service ... failing over to cached settings.", jqXHR );
								xConnect.utilities.setXbrcFromCache(function(){
									xConnect.utilities.subscribeToEvents();									
								});
							}
						});
					},
					convertURLtoVIP : function(facility, callback) {
						var urlString = facility.url + xConnect.data.xbrcCurrentConfigurationURL + '?random=' + Math.random();
									
						console.log("connecting to xBRC to get VIP: " + urlString + "\n");
						$.ajax( urlString , {
							timeout : xConnect.utilities.getXbrcTimeout(),
							dataType : "text",
							success : (function() {
								return function(data, textStatus, jqXHR){
									if( data ) {
										var reg = /.*vipaddress\"\>([^\<]*).*/,
											strings = data.match(reg);
											
										if( strings && strings.length ) {
											console.log(facility.name+' vipaddress: '+strings[1]);
											var vipaddress = strings[1].trim();
											if( vipaddress && vipaddress != '#' ) {
												var urlReg =  /http:\/\/([^\/:]*)(.*)/,
													urlStrings = facility.url.match(urlReg);
												
												console.log( 'Switching url ' + urlStrings[1] + ' to vip ' + vipaddress + ' for ' + facility.name );
												facility.url = 'http://' + vipaddress + urlStrings[2];
											}
										}
									}
									callback();
								};
							}()),
							error : (function(){
								return function(data, textStatus, jqXHR ) {
									console.log("error getting vip for "+facility.name);
								};
							}())
						});
					},
					isSoloOrMaster : function(facility, callback) {
						var urlString = facility.url + xConnect.data.xbrcStatusURL + '?random=' + Math.random();
									
						console.log("connecting to xBRC to get haStatus: " + urlString + "\n");
						$.ajax( urlString , {
							timeout : xConnect.utilities.getXbrcTimeout(),
							dataType : "text",
							success : (function() {
								return function(data, textStatus, jqXHR){
									if( data ) {
										var reg = /.*haStatus\>([^\<]*)\<\/haStatus.*/,
											strings = data.match(reg);
											
										if( strings && strings.length ) {
											console.log(facility.name+' haStatus = ' + strings[1]);
											var haStatus = strings[1].trim();
											if( haStatus && (haStatus.toLowerCase() == xConnect.data.soloModeString || haStatus.toLowerCase() == xConnect.data.masterModeString )) {
												callback();
											}
										}
									}
								};
							}()),
							error : (function(){
								return function(data, textStatus, jqXHR ) {
									console.log("error getting haStatus for " + facility.name);
								};
							}())
						});
					},
					saveXbrcsToSettings : function() {
                        var xbrcs = [];

						for( var xbrcIndex = 0; xbrcIndex < xConnect.data.xbrclist.length; xbrcIndex++ ) {
                            if ( xConnect.data.xbrclist[xbrcIndex] != null ) {
                                xbrcs.push(xConnect.data.xbrclist[xbrcIndex].url);
								console.log("Writing xbrc: " + xConnect.data.xbrclist[xbrcIndex].url);
                            }
						}

                        xConnect.cordovaPlugins.Settings["setXbrcs"](xbrcs);
					},
					loadLocations : function(callback) {
						//{"version":"1.0","type":"locationStatus","clientReference":"77777777","sessionId":"95DB6F5A-17F6-11E2-BF6A-980B6188709B"}
						var request = { version : "1.0",
										type : "locationStatus",
										clientReference : xConnect.utilities.generateClientReference(),
										sessionId : xConnect.data.GUID
									},
							urlString = "",
							xbrcCount = xConnect.data.xbrclist.length;
						
						// register event handlers for xbrc events
						xConnect.eventDispatcher.register(xConnect.eventDispatcher.locationStateChangeType, xConnect.data.locations.actions.handleLocationEvent);
						xConnect.eventDispatcher.register(xConnect.eventDispatcher.readerEventType, xConnect.data.locations.actions.handleReaderEvent);
						
						// zero out the current list
						xConnect.data.locations.list.length = 0;
						
						xConnect.data.xbrclist.forEach( function(xbrc){
							
							urlString = xbrc.url + xConnect.data.xbrcMessageUrl;
							
							xConnect.utilities.ajax( xbrc, urlString, request,
								(function(){
									return function(data, textStatus, jqXHR){
										var myLocation;
										if(data.locations) {
											data.locations.forEach(function(location){
												myLocation = {};
												xConnect.utilities.copyLocationData(location, myLocation);
												myLocation.xbrc = xbrc;
												myLocation.readers.forEach(function(reader){
													xConnect.data.locations.readerList.push({name:reader.name, reader:reader, location:myLocation});
												});
                                                console.log("Loaded location: " + myLocation.name);
												xConnect.data.locations.list.push(myLocation);
											});
											
											xConnect.data.locations.list.sort(function(a,b){
												return xConnect.data.locations.actions.compare(a.name, b.name);
											});
											xConnect.utilities.populateMyLocations();
										} else {
											console.log("XBRC " + xbrc.url + " has no locations defined");
										}
										
										// invoke the callback when we have received a response from all the xbrcs.
										if( --xbrcCount == 0 ) {
											if( xConnect.data.locations.list.length == 0 ) {
												xConnect.utilities.errorNotificationPageInit("Warning", "No locations found. The back end service is not configured." );
												xConnect.utilities.showNotificationPage();
											}
											callback();
										}
									};
							}()), 
							(function(){
								return function() {
									// on error decrement the count of xbrcs we're waiting for
									if( --xbrcCount == 0 ) {
										if( xConnect.data.locations.list.length == 0 ) {
											xConnect.utilities.errorNotificationPageInit("Warning", "No locations found. The back end service is not configured." );
											xConnect.utilities.showNotificationPage();
										}
										callback();
									}
								};
							}()));
						});
					}
				};

			}());

			// add reader utility comment page component to xConnect
			(function () {
				xConnect.utilitycommentpage = {
					comment : "",
					setup : function(config) {
						var commentSubmit = $('#commentbutton'),
							commentWidget = $('#utilitycomment');
					
						commentSubmit.text(config.buttonText); // need this for the first time through because the button isn't decorated
						commentSubmit.siblings('.ui-btn-inner').find('.ui-btn-text').text(config.buttonText);
						commentWidget.prop('value', config.comment);
						commentSubmit.off('click.xConnect.utility');
						commentSubmit.on('click.xConnect.utility', (function(){
							return function() {
								var commentWidget = $('#utilitycomment');
								
								xConnect.utilitycommentpage.comment = commentWidget.prop('value');
								xConnect.currentUtilityPage.actions[config.utilityFunction]();
								history.back();
							};
						}()));
					}
				}
			}());
			
			// add reader utility page component to xConnect
			(function () {
				xConnect.readerUtilityPage = {
					selectedReader : undefined,
					selectedReaderData : {},
					selectedReaderLocation : {},
					pageInit : function() {
						
					},
					locationEventHandler : function() {
						xConnect.readerUtilityPage.decorateLocation();
					},
					actions : {
						scheduleMaintenanceSetup : function() {
							var comment = "Scheduling touch point " + xConnect.readerUtilityPage.selectedReaderData.name + " for maintenance because: ";
							xConnect.utilitycommentpage.setup({comment:comment, utilityFunction:"scheduleMaintenance", buttonText: "Schedule Maintenance"} );
						},
						scheduleBioMaintenanceSetup : function() {
							var comment = "Scheduling biometric device " + xConnect.readerUtilityPage.selectedReaderData.name + " for maintenance because: ";
							xConnect.utilitycommentpage.setup({comment:comment, utilityFunction:"scheduleBioMaintenance", buttonText:"Schedule Bio Maintenance"} );
						},
						shutdownReaderSetup : function() {
							var comment = "Taking touch point " + xConnect.readerUtilityPage.selectedReaderData.name + " out of service because: ";
							xConnect.utilitycommentpage.setup({comment:comment, utilityFunction:"shutdownReader", buttonText : "Take Out of Service"} );
						},
						closeLocationSetup : function() {
							var comment = "Closing location " + xConnect.readerUtilityPage.selectedReaderLocation.name + " because: ";
							xConnect.utilitycommentpage.setup({comment:comment, utilityFunction:"closeLocation", buttonText : "Close Location"} );
						},
						scheduleMaintenance : function() {
							// {"version":"1.0","type":"scheduleMaintenance","clientReference":"77777777","sessionId":"95DB6F5A-17F6-11E2-BF6A-980B6188709B",
							// "reader":{"name":"V1-1","maitenance":{"reason":"Reader fails to play sounds."}}}


							var reader = xConnect.readerUtilityPage.selectedReaderData,
								comment = xConnect.utilitycommentpage.comment,
								location = xConnect.readerUtilityPage.selectedReaderLocation,
								request = { version : "1.0",
											type : "scheduleMaintenance",
											clientReference : xConnect.utilities.generateClientReference(),
											sessionId : xConnect.data.GUID,
											reader : {
												name : reader.name,
												maintenance : {
													reason : comment
												}
											}
										},
								urlString = location.xbrc.url + xConnect.data.xbrcMessageUrl;
							
							xConnect.utilities.ajax( location.xbrc, urlString, request, (function() {
										return function(data, textStatus, jqXHR){
											var myReader = {};
								
											// {"version":"1.0","type":"scheduleMaintenanceResponse","clientReference":"77777777",
											// "reader":{"state":"closed","lights":"off","response":"success","name":"V1-1"}}
	
											if( data.reader.response == "error" ) {
												// show error page
											}
										};
							}()));
						},
						scheduleBioMaintenance : function() {
							// {"version":"1.0","type":"scheduleBioMaintenance","clientReference":"77777777","sessionId":"95DB6F5A-17F6-11E2-BF6A-980B6188709B",
							// "reader":{"name":"V1-1","maitenance":{"reason":"Reader fails to play sounds."}}}
							var reader = xConnect.readerUtilityPage.selectedReaderData,
								location = xConnect.readerUtilityPage.selectedReaderLocation,
								comment = xConnect.utilitycommentpage.comment,
								request = { version : "1.0",
											type : "scheduleBioMaintenance",
											clientReference : xConnect.utilities.generateClientReference(),
											sessionId : xConnect.data.GUID,
											reader : {
												name : reader.name,
												maintenance : {
													reason : comment
												}
											}
										},
								urlString = location.xbrc.url + xConnect.data.xbrcMessageUrl;
							
							xConnect.utilities.ajax( location.xbrc, urlString, request, (function() {
										return function(data, textStatus, jqXHR){
											var myReader = {};
								
											// {"version":"1.0","type":"scheduleBioMaintenanceResponse","clientReference":"77777777",
											// "reader":{"state":"closed","lights":"off","response":"success","name":"V1-1"}}
											if( data.reader.response == "error" ) {
												// show error page
											}
										};
							}()));
						},
						shutdownReader : function() {
							// {"version":"1.0","type":"shutdownReader","clientReference":"77777777","sessionId":"95DB6F5A-17F6-11E2-BF6A-980B6188709B",
							// "reader":{"name":"entry-1", "shutdownReason":"Badly broken sound"}}}
							var reader = xConnect.readerUtilityPage.selectedReaderData,
								location = xConnect.readerUtilityPage.selectedReaderLocation,
								comment = xConnect.utilitycommentpage.comment,
								request = { version : "1.0",
											type : "shutdownReader",
											clientReference : xConnect.utilities.generateClientReference(),
											sessionId : xConnect.data.GUID,
											reader : {
												name : reader.name,
												shutdownReason : comment
												}
											},
								urlString = location.xbrc.url + xConnect.data.xbrcMessageUrl;
										
							xConnect.utilities.ajax( location.xbrc, urlString, request, (function() {
										return function(data, textStatus, jqXHR){
											// {"version":"1.0","type":"shutdownReaderResponse","clientReference":"77777777","reader":
											// {"state":"shutdown","response":"success","name":"entry-1","errorCode":"readerIsDisabled",
											// "errorDescription":"Reader has been shutdown."}}
											
											xConnect.utilities.copyReaderData(data.reader, reader);
											
											// rollup location state
											xConnect.utilities.rollupLocationState(location);
											
											// refresh the reader view in combinedView
											xConnect.combinedView.decorateReader(reader);
											
											// refresh the location view in combinedView
											xConnect.combinedView.decorateLocation(location);
											
											if( data.reader.response == "error" ) {
												// show error page
											}
										};
							}()));
						},
						closeLocation : function() {
							var location = xConnect.readerUtilityPage.selectedReaderLocation;
							
							// add comment to the outbound request here???
							xConnect.data.locations.actions.closeLocation(location);
							
							// refresh the view
							xConnect.combinedView.decorateLocation(location);
						}
					},
					decorateLocation : function() {
						var locationObject = $('#readerutilitylocation'),
							locationText = xConnect.readerUtilityPage.selectedReaderLocation.name + " : " + xConnect.readerUtilityPage.selectedReaderLocation.stateName;
					
						locationObject.text(locationText);
						
						if( xConnect.readerUtilityPage.selectedReaderLocation.state != "open" ) {
							$("#readerUtilityCloseLocationButton").addClass('ui-disabled');
						} else {
							$("#readerUtilityCloseLocationButton").removeClass('ui-disabled');
						}
					},
					selectReader : function (reader, data, location ) {
						var pageObject = $('#readerUtilityPage');
						
						// set the actions list so that the comment page knows which action to call
						xConnect.currentUtilityPage.actions = xConnect.readerUtilityPage.actions;
						
						// no longer want to receive location messages for the old location
						xConnect.eventDispatcher.unregister(xConnect.readerUtilityPage.selectedReaderLocation.name, xConnect.readerUtilityPage.locationEventHandler );
						// register to get the location state change messages for the new location
						xConnect.eventDispatcher.register(location.name, xConnect.readerUtilityPage.locationEventHandler );
						
						xConnect.readerUtilityPage.selectedReader = reader;
						xConnect.readerUtilityPage.selectedReaderData = data;
						xConnect.readerUtilityPage.selectedReaderLocation = location;

						// set the header and information fields
						if( pageObject) {
							var titleObject = pageObject.find('div[data-role="header"] h1'),
								readerObject = pageObject.find('#readerutilityreader'),
								readerText = xConnect.readerUtilityPage.selectedReaderData.name + " : " + xConnect.readerUtilityPage.selectedReaderData.tor;
							
							titleObject.text(xConnect.readerUtilityPage.selectedReaderData.name);
							readerObject.text(readerText);
							
							xConnect.readerUtilityPage.decorateLocation();
						}
						
					}
				};

			}());

			// add greeter utility page component to xConnect
			(function () {
				xConnect.greeterUtilityPage = {
					selectedGreeter : undefined,
					actions : {
						closeAllLocationsSetup : function() {
							var comment = "Closing all locations for greeter " + xConnect.greeterUtilityPage.selectedGreeter + " because: ";
							xConnect.utilitycommentpage.setup({comment:comment, utilityFunction:"closeAllLocations", buttonText:"Close All Locations"} );
						},
						closeAllLocations : function() {
							var locationList = xConnect.data.locations.list,
								greeterName = xConnect.greeterUtilityPage.selectedGreeter;
							
							locationList.forEach(function(location){
								if(location.cast && location.cast.portalId == greeterName ) {
									// add comment to the outbound request here???
									xConnect.data.locations.actions.closeLocation(location);
									
									// refresh the view
									xConnect.combinedView.decorateLocation(location);
								}
							});
							xConnect.greeterView.removeGreeter(greeterName);
						}
					},
					selectGreeter : function ( greeter ) {
						var pageObject = $('#greeterutilitypage'),
							titleWidget = pageObject.find('div[data-role="header"] h1'),
							labelWidget = $('#greeterUtilityLocationLabel'),
							locationsWidget = $('#greeterUtilityLocations'),
							locationList = xConnect.data.locations.list;
						
						xConnect.greeterUtilityPage.selectedGreeter = greeter;
						xConnect.currentUtilityPage.actions = xConnect.greeterUtilityPage.actions;
							
						titleWidget.text(greeter);

						locationsWidget.empty();
						locationList.forEach(function(location){
							if(location.cast && location.cast.portalId == greeter ) {
								var binder = xConnect.binder('#greeterutilityitemtemplate'),
									locationWidget = binder({name:location.name});
								
								locationsWidget.append(locationWidget);
								
								// hack to get it to render like the other content
								locationWidget.addClass('ui-li ui-li-static ui-btn-up-a ui-li-has-thumb ui-li-last');
								locationWidget.find('img').addClass('buttonicon ui-li-thumb');
							}
						});
					}
				};

			}());

			// add login page component to xConnect
			(function () {
				xConnect.loginPage = {
					pageInit : function() {
						$("#loginButton").on('click', function (e) {
							// actually login using the credentials in the page
							$("#portalid").blur();
							$("#password").blur();
							var userName = $("#portalid").val(),
								passwordWidget = $("#password"),
								password = passwordWidget.val();

                            // Only perform if we currently have network connectivity.
                            if ( xConnect.utilities.isConnected() ) {
                                $.mobile.loading('show');
                                passwordWidget.val(''); // empty it so it's not lying around.

                                // XHR to back end
                                // Success!!
                                xConnect.utilities.validateCredentials(userName, password, function(validated){
                                    $.mobile.loading('hide');
                                    if( validated ) {
                                        xConnect.utilities.loadLocations(function(){

                                            if (xConnect.data.user.role == xConnect.data.greeterRoleString) {
                                                $('#coordinatorModeSelector').css({display:'none'});
                                            } else if (xConnect.data.user.role == xConnect.data.coordinatorRoleString) {
                                                $('#coordinatorModeSelector').css({display:'block'});
                                            }

                                            if (xConnect.utilities.actingAsGreeter()) {
                                                xConnect.loginPage.prepForGreeter();
                                            } else if (xConnect.data.user.role == xConnect.data.coordinatorRoleString) {
                                                xConnect.loginPage.prepForCoordinator();
                                            } else {
                                                // unknown role
                                                alert("You must configured as a greeter or coordinator in keystone to use this application");
                                            }
                                        });
                                    } else {
                                        // show error and return to login screen
                                        xConnect.utilities.errorNotificationPageInit("Login Error", "Please try again." );
                                        xConnect.utilities.showNotificationPage();
                                    }
                                });
                            }
                            else {
                                // We are having network connectivity issues.
                                xConnect.utilities.errorNotificationPageInit("Network Error", "Network Unavailable." );
                                xConnect.utilities.showNotificationPage();
                            }
						});
					},
					prepForCoordinator : function() {
						var currentPage = $.mobile.activePage.attr('id');
						
						if( currentPage != 'loginPage' && xConnect.data.user.myLocations.length > 0 ) {
							// confirm close before loging out
							xConnect.utilities.selectors.values.coordinatorModeSelector = "Greeter";
							xConnect.utilities.showConfirmSwitchMode();
						} else {
							xConnect.loginPage.performPrepForCoordinator();
						}
					},
					performPrepForCoordinator : function() {
						var currentPage = $.mobile.activePage.attr('id');
						
						xConnect.utilities.selectors.values.coordinatorModeSelector = "Coordinator";
						xConnect.utilities.decorateSelectors();
						xConnect.data.user.myLocations.forEach(function(location){
							xConnect.data.locations.actions.closeLocation(location);
						});
						
						if( currentPage != 'loginPage') {
							xConnect.utilities.hideCastActions();
						}
						
						$.mobile.changePage("#combinedView");
						xConnect.combinedView.setup();
					},
					prepForGreeter : function() {
						xConnect.utilities.populateMyLocations();
						$.mobile.changePage("#locationView");
						xConnect.locationView.setup();
					}
				};
			}());

			// add current utility page component to xConnect
			(function () {
				xConnect.currentUtilityPage = {
					actions : []
				}
			}());

            // add reader UI component to xConnect
            (function () {
                xConnect.reader = {
                    states : {
                        
                    },
                    greenTimeoutIds : {},
                    clearGreenTimeouts : function(readerName) {
                        var greenTimeoutIds = xConnect.reader.greenTimeoutIds;
                        
                        if(greenTimeoutIds[readerName]) {
                            greenTimeoutIds[readerName].forEach(function(timeoutId){
                                clearTimeout(timeoutId);
                            });
                            greenTimeoutIds[readerName].length = 0;
                        }
                    },
                    addGreenTimeoutId : function(readerName, timeoutId) {
                        var greenTimeoutIds = xConnect.reader.greenTimeoutIds;
                        
                        if(!greenTimeoutIds[readerName]) {
                            greenTimeoutIds[readerName] = [];
                        }
                        
                        greenTimeoutIds[readerName].push(timeoutId);
                    },
                    decorator : function(context) {
                        xConnect.reader.clearGreenTimeouts(context.reader.name);
                        
                        if( context.readerWidget == undefined ) {
                            context.readerWidget = $("#"+context.reader.label+"state");
                        }
             
                        var readerItem = xConnect.data.locations.actions.findReaderByName( context.reader.name );
                        if ( readerItem.location.xbrc.isOffline ) {
                            xConnect.utilities.disableLink(context.readerWidget);
                        }
                        else {
                            xConnect.utilities.enableLink(context.readerWidget);
                        }
                        
                        var targets = context.readerWidget.find('[data-bind^="reader."]');
                        
                        targets.each(function(target){
                            var bindName = $(this).attr('data-bind'),
                                widgetName = bindName + "Widget",
                                nameParts = bindName.split('.');
                            
                            context[widgetName] = $(this);
                            if( context.decorators && context.decorators[nameParts[1]] ) { // context decorators overide defaults
                                context.decorators[nameParts[1]].decorator(context);
                            } else {
                                if( xConnect.reader.decorators[nameParts[1]] != undefined ) {
                                    xConnect.reader.decorators[nameParts[1]].decorator(context);
                                }
                                // igore bind attributes for which we have no decorator
                            }
                        });
                    },
                    decorators : {
                        name : {
                            decorator: function(context) {
                                if( context.readerWidget == undefined || context.reader == undefined ) {
                                    // ignore the request if we don't know where to draw it
                                    console.log('decorator had no context');
                                    return;
                                }
                                
                                if( context.readerNameWidget == undefined ) {
                                    context.readerNameWidget = context.readerWidget.find('[data-bind="reader.name"]');
                                }
                                
                                if( context.readerNameWidget.length == 0 ) {
                                    // nothing to do ... no target widget
                                    return;
                                }
                                
                                context.readerNameWidget.text( context.reader.name );
                            }
                        },
                        logicalState : {
                            decorator : function( context ) {
                                if( context.readerWidget == undefined || context.reader == undefined ) {
                                    // ignore the request if we don't know where to draw it
                                    console.log('decorator had no context');
                                    return;
                                }
                                
                                if( context.readerStateWidget == undefined ) {
                                    context.readerStateWidget = context.readerWidget.find('[data-bind="reader.logicalState"]');
                                }
                                
                                if( context.readerStateWidget.length == 0 ) {
                                    // no target widget ... nothing to do
                                    return;
                                }
                                
                                if( context.iconName == undefined ) {
                                    context.iconName = xConnect.utilities.getReaderIconName(context.reader);
                                }
                
                                var readerItem = xConnect.data.locations.actions.findReaderByName( context.reader.name );
                                if ( readerItem.location.xbrc.isOffline ) {
                                    context.readerStateWidget.text(xConnect.data.xbrcSystemOfflineString);
                                }
                                else {
                                    if( context.iconName == xConnect.data.readerIconNames.blue || context.iconName == xConnect.data.readerIconNames.shutdown ){
                                        context.readerStateWidget.text(context.reader.errorDescription || "Error" );
                                    } else {
                                        context.readerStateWidget.text(context.iconName);
                                    }
                                }
                            }
                        },
                        icon : {
                            decorator : function(context) {
                                if( context.readerWidget == undefined || context.reader == undefined ) {
                                    // ignore the request if we don't know where to draw it
                                    console.log('decorator had no context');
                                    return;
                                }
                                
                                if( context.readerIconWidget == undefined ) {
                                    context.readerIconWidget = context.readerWidget.find('[data-bind="reader.icon"]');
                                }
                                
                                if( context.readerIconWidget.length == 0 ) {
                                    // nothing to do ... no target widget
                                    return;
                                }
                                
                                if( context.iconName == undefined ) {
                                    context.iconName = xConnect.utilities.getReaderIconName(context.reader);
                                }
                                
                                // set image source
                                context.readerIconWidget.attr( 'src', "img/reader-" + context.iconName + ".png");
                                
                                if( context.iconName == xConnect.data.readerIconNames.green ) {
                                    // start timer to clear the event after xxx seconds
                                    var timeoutId = setTimeout( (function() {
                                        return function() {
                                            // remove the timeoutId from the list
                                            xConnect.reader.clearGreenTimeouts(context.reader.name);
                                            
                                            // set the reader state
                                            context.reader.lights = "off";
                                            xConnect.reader.decorator({reader:context.reader, readerWidget: context.readerWidget});
                                        };												
                                    }()), xConnect.data.greenTimeout );
                                    
                                    xConnect.reader.addGreenTimeoutId(context.reader.name, timeoutId);
                                }
                            }
                        },
                        tor : {
                            decorator : function(context) {
                                if( context.readerWidget == undefined || context.reader == undefined ) {
                                    // ignore the request if we don't know where to draw it
                                    console.log('decorator had no context');
                                    return;
                                }
                                
                                if( context.readerTorWidget == undefined ) {
                                    context.readerTorWidget = context.readerWidget.find('[data-bind="reader.tor"]');
                                }
                                
                                if( context.readerTorWidget.length == 0 ) {
                                    // no target widget ... nothing to do
                                    return;
                                }
                                
                                context.readerTorWidget.text(context.reader.tor || "No TOR" );
                            }
                        },
                        torDescription : {
                            decorator : function(context) {
                                
                            }
                        },
                        state : {
                            decorator : function(context) {
                                
                            }
                        },
                        errorCode : {
                            decorator : function(context) {
                                
                            }
                        },
                        errorDescription : {
                            decorator : function(context) {
                                
                            }
                        },
                        celebrations : {
                            decorator : function(context) {
                                if( context.readerWidget == undefined || context.reader == undefined ) {
                                    // ignore the request if we don't know where to draw it
                                    console.log('decorator had no context');
                                    return;
                                }
                                
                                if( context.readerCelebrationsWidget == undefined ) {
                                    context.readerCelebrationsWidget = context.readerWidget.find('[data-bind="reader.celebrations"]');
                                }
                                
                                if( context.readerCelebrationsWidget.length == 0 ) {
                                    // no target widget ... nothing to do
                                    return;
                                }
                                                            
                                if( context.iconName == undefined ) {
                                    context.iconName = xConnect.utilities.getReaderIconName(context.reader);
                                }
                                
                                // celebrations are only interesting on green states
                                if( context.iconName != xConnect.data.readerIconNames.green ){
                                    context.readerCelebrationsWidget.text("");
                                } else {
                                    if( context.reader.guest.celebrations && context.reader.guest.celebrations[0] ) {
                                        context.readerCelebrationsWidget.text(context.reader.guest.celebrations[0].name);
                                    } else {
                                        context.readerCelebrationsWidget.text("");
                                    }
                                }
                            }
                        },
                        guest : {
                            decorator : function(context) {
                                var targets = context.readerWidget.find('[data-bind^="reader.guest."]');
                                
                                targets.each(function(target){
                                    var bindName = $(this).attr('data-bind'),
                                        widgetName = bindName + "Widget",
                                        nameParts = bindName.split('.');
                                    
                                    context[widgetName] = $(this);
                                    if( context.decorators && context.decorators.guest && context.decorators.guest.decorators && context.decorators.guest.decorators[nameParts[2]] ) { // context decorators overide defaults
                                        context.decorators.guest.decorators[nameParts[2]].decorator(context);
                                    } else {
                                        if( xConnect.reader.decorators.guest.decorators[nameParts[2]] != undefined ) {
                                            xConnect.reader.decorators.guest.decorators[nameParts[2]].decorator(context);
                                        }
                                        // igore bind attributes for which we have no decorator
                                    }
                                });
                            },
                            decorators : {
                                name : {
                                    decorator : function (context) {
                                        if( context.readerWidget == undefined || context.reader == undefined ) {
                                            // ignore the request if we don't know where to draw it
                                            console.log('decorator had no context');
                                            return;
                                        }
                                        
                                        if( context.readerGuestNameWidget == undefined ) {
                                            context.readerGuestNameWidget = context.readerWidget.find('[data-bind="reader.guest.name"]');
                                        }
                                        
                                        if( context.readerGuestNameWidget.length == 0 ) {
                                            // nothing to do ... no target widget
                                            return;
                                        }
                                        
                                        if( context.iconName == undefined ) {
                                            context.iconName = xConnect.utilities.getReaderIconName(context.reader);
                                        }
                                        
                                        // guest names are only valid on blue or green states
                                        if( context.iconName != xConnect.data.readerIconNames.blue && context.iconName != xConnect.data.readerIconNames.green ){
                                            delete context.reader.guest;
                                            context.readerGuestNameWidget.text("");
                                        } else {
                                            if( context.reader.guest ) { // guest may not have been initialized yet
                                                context.readerGuestNameWidget.text(context.reader.guest.firstName + " " + context.reader.guest.lastName);
                                            } else {
                                                context.readerGuestNameWidget.text("Unknown guest");
                                            }
                                        }
                                    }
                                },
                                child : {
                                    decorator : function(context) {
                                        var isChild = false;
                                        
                                        if( context.readerWidget == undefined || context.reader == undefined ) {
                                            // ignore the request if we don't know where to draw it
                                            console.log('decorator had no context');
                                            return;
                                        }
                                        
                                        if( context.readerGuestChildWidget == undefined ) {
                                            context.readerGuestChildWidget = context.readerWidget.find('[data-bind="reader.guest.child"]');
                                        }
                                        
                                        if( context.readerGuestChildWidget.length == 0 ) {
                                            // no target widget ... nothing to do
                                            return;
                                        }
                                        
                                        if( context.iconName == undefined ) {
                                            context.iconName = xConnect.utilities.getReaderIconName(context.reader);
                                        }
                                        
                                        if( context.reader.guest ) {
                                            isChild = context.reader.guest.flashAtTurnstile;
                                        }
                                        
                                        // guest names are only valid on blue or green states
                                        if( context.iconName != xConnect.data.readerIconNames.blue && context.iconName != xConnect.data.readerIconNames.green ){
                                            context.readerGuestChildWidget.text("");
                                        } else {
                                            context.readerGuestChildWidget.text(isChild?"CHILD":"");
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }());


			// add reader view component to xConnect
			(function () {
				xConnect.readerView = {
					pageInit : function() {
						xConnect.eventDispatcher.register(xConnect.eventDispatcher.myLocationsType, xConnect.readerView.handleMyLocationsEvent);
					},
					handleMyLocationsEvent : function(e) {
						// Now that myLocations has changed, update the list of readers
						xConnect.readerView.loadReaders();
						
						// if we're not monitoring any locations ... head back to the locationView page
						if( xConnect.data.user.myLocations.length == 0 ) {
							// need to figure out how to direct the back button of the bump notification page to the locationView
							if( $.mobile.activePage.attr('id') == 'readerView'){
								$.mobile.changePage('#locationView');	
							}
						}
					},
					helpers : {},
					defaultHelpers : {
						hideBlueButtons : function(readerWidget) {
							readerWidget.find(".readerBlueButtons").css("display","none");
						},
						showBlueButtons : function(readerWidget) {
							readerWidget.find(".readerBlueButtons").css("display","block");
						},
						hideChildFlag : function(childWidget) {
							childWidget.text('');
						},
						showChildFlag : function(childWidget) {
							childWidget.text('CHILD');
						}
					},
					twoUpHelpers : {
						hideBlueButtons : function(readerWidget) {
							readerWidget.find(".readerBlueButtons").addClass("ui-disabled");
						},
						showBlueButtons : function(readerWidget) {
							readerWidget.find(".readerBlueButtons").removeClass("ui-disabled");
						},
						hideChildFlag : function(widget) {
							xConnect.readerView.twoUpHelpers.hideFlag( widget, 'img/nochild120.png' );
						},
						showChildFlag : function(widget) {
							xConnect.readerView.twoUpHelpers.showFlag( widget, 'img/child120.png' );
						},
						hideCelebrationFlag : function(widget) {
							xConnect.readerView.twoUpHelpers.hideFlag( widget, 'img/nocelebration120.png' );
						},
						showCelebrationFlag : function(widget) {
							xConnect.readerView.twoUpHelpers.showFlag( widget, 'img/celebration120.png' );
						},
						hideFlag : function( widget, imgSrc ) {
							widget.attr( 'src', imgSrc );
							widget.addClass('gaOff');
						},
						showFlag : function(widget, imgSrc ) {
							widget.attr( 'src', imgSrc );
							widget.removeClass('gaOff');
						}
					},
					defaultDecorators : {
						blueButtons : {
							decorator : function(context) {
								if( context.readerWidget == undefined || context.reader == undefined ) {
									// ignore the request if we don't know where to draw it
									console.log('decorate reader icon had no context');
									return;
								}
								
								if( context.readerBlueButtonsWidget == undefined ) {
									context.readerBlueButtonsWidget = context.readerWidget.find('[data-bind="reader.blueButtons"]');
								}
								
								if( context.readerBlueButtonsWidget.length == 0 ) {
									// no target widget ... nothing to do
									return;
								}
								
								if( context.iconName == undefined ) {
									context.iconName = xConnect.utilities.getReaderIconName(reader);
								}
								
								// hide the blue buttons if it's not a blue event
								if( context.iconName == xConnect.data.readerIconNames.blue ){
									context.readerBlueButtonsWidget.css("display","block");
								} else {
									context.readerBlueButtonsWidget.css("display","none");
								}
							}
						}
					},
					twoUpDecorators : {
						blueButtons : {
							decorator : function(context) {
								if( context.readerWidget == undefined || context.reader == undefined ) {
									// ignore the request if we don't know where to draw it
									console.log('decorate reader icon had no context');
									return;
								}
								
								if( context.readerBlueButtonsWidget == undefined ) {
									context.readerBlueButtonsWidget = context.readerWidget.find('[data-bind="reader.blueButtons"]');
								}
								
								if( context.readerBlueButtonsWidget.length == 0 ) {
									// no target widget ... nothing to do
									return;
								}
								
								if( context.iconName == undefined ) {
									context.iconName = xConnect.utilities.getReaderIconName(reader);
								}
								
								// hide the blue buttons if it's not a blue event
								if( context.iconName == xConnect.data.readerIconNames.blue ){
									context.readerBlueButtonsWidget.removeClass('ui-disabled');
								} else {
									context.readerBlueButtonsWidget.addClass('ui-disabled');
								}
							}
						},
						icon : {
							decorator : function(context) {
								if( context.readerWidget == undefined || context.reader == undefined ) {
									// ignore the request if we don't know where to draw it
									console.log('decorate reader icon had no context');
									return;
								}
								
								if( context.readerIconWidget == undefined ) {
									context.readerIconWidget = context.readerWidget.find('[data-bind="reader.icon"]');
								}
								
								if( context.readerIconWidget.length == 0 ) {
									// nothing to do ... no target widget
									return;
								}
								
								if( context.iconName == undefined ) {
									context.iconName = xConnect.utilities.getReaderIconName(context.reader);
								}
								
								// set image source
								context.readerIconWidget.attr( 'src', "img/reader-" + context.iconName + "256" + ".png");
								
								if( context.iconName == xConnect.data.readerIconNames.green ) {
									// start timer to clear the event after xxx seconds
									var timeoutId = setTimeout( (function() {
										return function() {
											// remove the timeoutId from the list
											xConnect.reader.clearGreenTimeouts(context.reader.name);
											
											// set the reader state
											context.reader.lights = "off";
											xConnect.reader.decorator({reader:context.reader, readerWidget: context.readerWidget, decorators: context.decorators});
										};												
									}()), xConnect.data.greenTimeout );
									
									xConnect.reader.addGreenTimeoutId(context.reader.name, timeoutId);
								}
							}
						},
						celebrations : {
							decorator : function(context) {
								var isCelebration = false;
								
								if( context.readerWidget == undefined || context.reader == undefined ) {
									// ignore the request if we don't know where to draw it
									console.log('decorator had no context');
									return;
								}
								
								if( context.readerCelebrationsWidget == undefined ) {
									context.readerCelebrationsWidget = context.readerWidget.find('[data-bind="reader.celebrations"]');
								}
								
								if( context.readerCelebrationsWidget.length == 0 ) {
									// no target widget ... nothing to do
									return;
								}
															
								if( context.iconName == undefined ) {
									context.iconName = xConnect.utilities.getReaderIconName(context.reader);
								}
								
								// any celebrations ?
								if( context.reader.guest && context.reader.guest.celebrations && context.reader.guest.celebrations[0]) {
									isCelebration = true;
								}
								
								// celebrations are only interesting on green states
								if( isCelebration && context.iconName == xConnect.data.readerIconNames.green ) {
									xConnect.readerView.twoUpHelpers.showCelebrationFlag(context.readerCelebrationsWidget);
								} else {
									xConnect.readerView.twoUpHelpers.hideCelebrationFlag(context.readerCelebrationsWidget);
								}
							}
						},
						guest : {
							decorator : xConnect.reader.decorators.guest.decorator,
							decorators : {
								child : {
									decorator : function(context) {
										var isChild = false;
										
										if( context.readerWidget == undefined || context.reader == undefined ) {
											// ignore the request if we don't know where to draw it
											console.log('decorate reader icon had no context');
											return;
										}
										
										if( context.readerGuestChildWidget == undefined ) {
											context.readerGuestChildWidget = context.readerWidget.find('[data-bind="reader.guest.child"]');
										}
										
										if( context.readerGuestChildWidget.length == 0 ) {
											// no target widget ... nothing to do
											return;
										}
										
										if( context.iconName == undefined ) {
											context.iconName = xConnect.utilities.getReaderIconName(context.reader);
										}
										
										if( context.reader.guest ) {
											isChild = context.reader.guest.flashAtTurnstile;
										}
										
										// guest names are only valid on blue or green states
										if( isChild && (context.iconName == xConnect.data.readerIconNames.blue || context.iconName == xConnect.data.readerIconNames.green ) ){
											xConnect.readerView.helpers.showChildFlag(context.readerGuestChildWidget);
										} else {
											xConnect.readerView.helpers.hideChildFlag(context.readerGuestChildWidget);
										}
									}
								}
							}
						}
					},
					decorators : {
						
					},
					decorateReader : function(reader){
						var readerWidget = $("#"+reader.label+"state");
						
						xConnect.reader.decorator({reader:reader, readerWidget:readerWidget, decorators : xConnect.readerView.decorators });
					},
					loadReaders : function () {
						var numberOfReaders = xConnect.data.user.getMyReadersCount(),
							binder = {},
							readerList = $("#greeterreadermonitorlist"),
							myLocations = xConnect.data.user.myLocations;

						if( numberOfReaders < 3 ) {
							binder = xConnect.binder("#readeritem2uptemplate");
							xConnect.readerView.decorators = xConnect.readerView.twoUpDecorators;
							xConnect.readerView.helpers = xConnect.readerView.twoUpHelpers;
						} else {
							binder = xConnect.binder("#readeritemtemplate");
							xConnect.readerView.decorators = xConnect.readerView.defaultDecorators;
							xConnect.readerView.helpers = xConnect.readerView.defaultHelpers;
						}
						
						readerList.empty();
						
						myLocations.forEach( function(location, locationIndex) {
							// set the castID associated with this location to this user
							// location.cast = xConnect.data.user.id;

							// register this cast member as owning these readers in TOR
							// some call to xBRC
							location.readers.forEach( function(reader) {
								var newReader = binder({name: reader.name, id : reader.label + "state"});
																
								var makeClickHandler = function( buttonType ){
									return function() {
										// {"version":"1.0","type":"readerRedirect","clientReference":"77777777","sessionId":"95DB6F5A-17F6-11E2-BF6A-980B6188709B",
										// "reader":{"name":"V1-1"}}

										var request = { version : "1.0",
												type : "reader" + buttonType,
												clientReference : xConnect.utilities.generateClientReference(),
												sessionId : xConnect.data.GUID,
												reader : {
													name : reader.name
													}
												},
											urlString = location.xbrc.url + xConnect.data.xbrcMessageUrl;
											
										// remove buttons immediately to prevent a retap
										xConnect.readerView.helpers.hideBlueButtons(newReader);
										
										xConnect.utilities.ajax( location.xbrc, urlString, request, (function() {
											return function(data, textStatus, jqXHR){
												var myReader = {};
									
												// {"version":"1.0","type":"readerRedirectResponse","clientReference":"77777777","reader":{"state":"open","lights":"off",
												// "response":"success","name":"V1-1"}}
												
												// nothing to do here ... actual decoration will happen when we get the reader state change event
											};
										}()));
										
										// The UI will be updated in the handler when we receive the readerEvent 
									};
								};
								
								// set blue event redirect button click handler
								newReader.find('.redirectButton').on('click', makeClickHandler("Redirect"));
								
								// set blue event retry button click handler
								newReader.find('.retryButton').on('click', makeClickHandler('Retry'));
								
								xConnect.eventDispatcher.register( reader.name, xConnect.readerView.handleReaderEvent );
																								
								readerList.append(newReader);
								
								xConnect.readerView.decorateReader(reader);
							});
						});
						
						try {
							readerList.listview('refresh');
							readerList.trigger('create');
						}catch(e) {
							// ignore failure
						}
						
					},
					handleReaderEvent : function(e) {
						xConnect.readerView.decorateReader(e.message.reader);
					}
				};

			}());


			// add notification, castActions, errors and the dark Div that goes behind them component to xConnect
			(function () {
				xConnect.darkDiv = {
					pageInit : function() {
						xConnect.utilities.selectors.callbacks.coordinatorModeSelector = function(e){
							if( xConnect.utilities.selectors.values.coordinatorModeSelector == "Coordinator" ) {
								// close all open locations
								xConnect.loginPage.prepForCoordinator();
							} else {
								xConnect.loginPage.prepForGreeter();
								xConnect.utilities.hideCastActions();
							}
						};
					}
				}
			}());

            function onDeviceReady(){
                xConnect.utilities.appInit(function() { // pass a callback so that we know
                    xConnect.utilities.initializeAppData();

                    $.mobile.loading('hide');
                });
            }

            if(xConnect.utilities.isPhoneGap()){
                document.addEventListener("deviceready",onDeviceReady,false);
            }else{
                $(document).ready(function(){
                    onDeviceReady();
                });
            }
		</script>
	</head>
	<body>
		<div id="darkDiv">
			<script>
				// set up callback for the coordinator mode selector
				xConnect.darkDiv.pageInit();
			</script>
			<div id='castActionMenu'>
				<div class="pointyBit">
					<img src='img/pointybit.png'/>
				</div>
				<div class='belowPointyBit'>
	

					<div class="gaSelector" id='coordinatorModeSelector'>
						<div class="gaSelectorButton">
							<div class="gaSelectorIcon"></div>
							<span class='gaSelectorText'>Coordinator</span>
						</div>
						<div class="gaSelectorButton">
							<div class="gaSelectorIcon"></div>
							<span class="gaSelectorText">Greeter</span>
						</div>
					</div>
					<div id="logoutButton" data-corners="true" data-shadow="true" data-iconshadow="true" data-wrapperels="span" data-icon="null" data-iconpos="null" data-theme="b" data-inline="false" class="ui-btn ui-shadow ui-btn-corner-all ui-btn-block ui-btn-up-b" aria-disabled="false">
						<span class="ui-btn-inner ui-btn-corner-all">
							<span class="ui-btn-text">Logout</span>
						</span>
						<button class="ui-btn-hidden" id="castActionLogoutButton" data-theme="b" data-inline="false" aria-disabled="false">Logout</button>
					</div>
					<div id="confirmLogoutDiv">
						<div style="text-align:center;">
							<img class='gaIcon' src='img/warning.png'>
							<div class="gaWarning">You Have<br>Open Locations</div>
						</div>
						<ul>
							<li>ALPHA1-Left</li>
							<li>ALPHA1-Right</li>
						</ul>
						<div id="confirmLogoutButton" data-corners="true" data-shadow="true" data-iconshadow="true" data-wrapperels="span" data-icon="null" data-iconpos="null" data-theme="b" data-inline="false" class="ui-btn ui-shadow ui-btn-corner-all ui-btn-block ui-btn-up-b" aria-disabled="false">
							<span class="ui-btn-inner ui-btn-corner-all">
								<span class="ui-btn-text">Close & Logout</span>
							</span>
							<button class="ui-btn-hidden" id="castActionConfirmLogoutButton" data-theme="b" data-inline="false" aria-disabled="false">Close & Logout</button>
						</div>
						<div id="confirmSwitchButton" data-corners="true" data-shadow="true" data-iconshadow="true" data-wrapperels="span" data-icon="null" data-iconpos="null" data-theme="b" data-inline="false" class="ui-btn ui-shadow ui-btn-corner-all ui-btn-block ui-btn-up-b" aria-disabled="false">
							<span class="ui-btn-inner ui-btn-corner-all">
								<span class="ui-btn-text">Close & Switch</span>
							</span>
							<button class="ui-btn-hidden" id="castActionConfirmLogoutButton" data-theme="b" data-inline="false" aria-disabled="false">Close & Switch</button>
						</div>
					</div>
					<div data-corners="true" data-shadow="true" data-iconshadow="true" data-wrapperels="span" data-icon="null" data-iconpos="null" data-theme="c" data-inline="false" class="ui-btn ui-shadow ui-btn-corner-all ui-btn-block ui-btn-up-c" aria-disabled="false">
						<span class="ui-btn-inner ui-btn-corner-all">
							<span class="ui-btn-text">Cancel</span>
						</span>
						<button class="ui-btn-hidden" id="castActionCancelButton" data-theme="c" data-inline="false" aria-disabled="false">Cancel</button>
					</div>
                    <div id="appVersion">
                        <span></span>
                    </div>
				</div>
			</div>
			<div id='notificationDetails'>
				<h1>Bump Notification</h1>
				<h3>You have been bumped by Joe Blow</h3>
				<div data-corners="true" data-shadow="true" data-iconshadow="true" data-wrapperels="span" data-icon="null" data-iconpos="null" data-theme="b" data-inline="false" class="ui-btn ui-shadow ui-btn-corner-all ui-btn-block ui-btn-up-b" aria-disabled="false">
					<span class="ui-btn-inner ui-btn-corner-all">
						<span class="ui-btn-text">Got it!</span>
					</span>
					<button class="ui-btn-hidden" id="notificationGotItButton" data-theme="b" data-inline="false" aria-disabled="false">Got it!</button>
				</div>
			</div>
		</div>
		<div id="phonescreen">
		
		
<!-- ********************************************* -->
<!-- Login page -->

			<div data-role="page" id="loginPage">
				<script>
					$('#loginPage').on('pageinit', function (event) {
						xConnect.loginPage.pageInit();
					});
				</script>
				<div data-role="content">
					<div class="logindiv">
						<img class="disneylogo" src="img/disneylogo.iphone@2x.png"/>
						<br/>
						<label id="idlabel" for="portalid" class="loginlabel">Cast HUB ID</label>
						<input type="text" name="name" id="portalid" />
						<label id="pwlabel" for="password" class="loginlabel">Password</label>
						<input type="password" name="password" id="password" />
						<br class="loginbuttonspacer">
						<button id="loginButton" data-theme="b" data-inline="false">Login</button>
					</div>
				</div>
			</div>

<!-- ********************************************* -->
<!-- Location View -->

			<div data-role="page" id="locationView">
				<script>
					$('#locationView').on('pageinit', function (event) {
						xConnect.locationView.pageInit();
					});
				</script>
				<div data-role="header" data-position="fixed">
                    <div id="locationViewCastAction"></div>
                    <h1 id="greeterid">Greeter</h1>
				</div>
				<div class="gaContent" data-role="content" data-theme='c'>
					<ul class="gaList" data-role="listview">
						<li class="gaListItem">
							<div class='gaCenter venueLabel'>
								<span class="venueName">My venue</span>
							</div>
						</li>
					</ul>

					<ul class="gaList" data-role="listview" data-theme='e'>
						<li id="myReadersLineItem" class="gaListItem">
							<a class='gaListItem' id="myReadersButton" href='#readerView' data-transition="none">
								<img class="gaIcon" src="img/reader-Closed.png" alt="My Touch Points">
								<span class="gaLeftText">My Touch Points</span> 
								<span class="ui-li-count">2</span>
							</a>
						</li>
					</ul>

					<div id="locationviewdiv"></div>
				</div>
			</div>


<!-- ********************************************* -->
<!-- Location Details -->

			<div data-role="page" id="locationDetails">
				<script>
					var myPage = $('#locationDetails');
					
					myPage.on('pageinit', function (event) {
						xConnect.locationDetails.pageInit();
					});
				</script>
				<div data-role="header" data-position="fixed">
					<a href="#" data-rel="back" data-icon="arrow-l">Locations</a>
					 <h1>Location 123</h1>
				</div>

				<div class='gaContent' data-role="content">
					<ul data-role="listview" class='gaList'>
						<li class='gaListItem'>
							<a class="utility gaListItem" data-xconnect-utility="Map" href="#venueMap" data-theme="b">
								<img class='buttonicon gaIcon' src='img/venue.png'/>
								<span class="firstlineutility gaLeftText">Venue Map</span>
							</a>
						</li>
					</ul>
					<div class="utilitydivider">Touch Points At This Location</div>
					<ul id="locationdetailsreaders" class="gaList locationdetailsinfo" data-role="listview" data-theme="a">
						<li class='gaListItem'>TP1</li>
						<li class='gaListItem'>TP2</li>
					</ul>
					<div class='gaPaddedItem'>
						<button class="locationdetailsaction gaButton" id="locationdetailsactionbutton" data-theme="b" data-inline="false">Open</button>
						<div id="locationdetailsflashdiv">
							<button class="locationdetailsaction gaButton" id="flashbutton" data-theme="b" data-inline="false">Flash Location</button>
						</div>
					</div>
				</div>
			</div>

<!-- ********************************************* -->
<!-- Combined View page -->

			<div data-role="page" id="combinedView">
				<script>
					$('#combinedView').on('pageinit', function (event) {
						xConnect.combinedView.pageInit();
					});
				</script>
				<div data-role="header" data-position="fixed">
					<div id="combinedViewCastAction"></div>
					<h1 class='castLabel'><span>Coordinator</span></h1>
					<div id="combinedGreeterToggle">
						<div id="invisibleCombinedToggle"></div>
						<div id="invisibleGreeterToggle"></div>
					</div>
				</div>
				<div class='gaContent' data-role="content" data-theme='c'>
					<ul class="gaList" data-role="listview">
						<li class='gaListItem'>
							<div class='gaCenter venueLabel'>
								<span class="venueName">My venue</span>
							</div>
						</li>
					</ul>

					<div id="combinedviewlist">

					</div>
				</div>
			</div>

<!-- ********************************************* -->
<!-- Greeter View page -->

			<div data-role="page" id="greeterview">
				<script>
					$('#greeterview').on('pageinit', function (event) {
						xConnect.greeterView.pageInit();
					});
				</script>
				<div data-role="header" data-position="fixed">
					<h1 class='castLabel'><span>Coordinator</span></h1>

				</div>
				<div class='gaContent' data-role="content" data-theme='c'>
					<div id="greeterviewlist"></div>
				</div>
			</div>

<!-- ********************************************* -->
<!-- Venue page -->

			<div id="venueSelectionPage" data-role="page" data-theme="c">
				<script>
					$('#venueSelectionPage').on('pageinit', function (event) {
						xConnect.venueSelectionPage.pageInit();
					});
				</script>
				<div data-role="header" data-position="fixed">
					<a data-rel="back" href="#" data-icon="arrow-l">Back</a>
					<span class="ui-title"></span>
				</div>
				<div class='gaContent' data-role="content">
					<div class="whereAreYou">Where are you?</div>
					<div class="gaSelector" id='venueSelector'>
						<div class="gaSelectorButton">
							<div class="gaSelectorIcon"></div>
							<span class='gaSelectorText'>Magic Kingdom</span>
						</div>
						<div class="gaSelectorButton">
							<div class="gaSelectorIcon"></div>
							<span class="gaSelectorText">Animal Kingdom</span>
						</div>
						<div class="gaSelectorButton">
							<div class="gaSelectorIcon"></div>
							<span class="gaSelectorText">Epcot</span>
						</div>
						<div class="gaSelectorButton">
							<div class="gaSelectorIcon"></div>
							<span class="gaSelectorText">Hollywood Studios</span>
						</div>
						<div class="gaSelectorButton">
							<div class="gaSelectorIcon"></div>
							<span class="gaSelectorText">Downtown Disney</span>
						</div>
						<div class="gaSelectorButton">
							<div class="gaSelectorIcon"></div>
							<span class="gaSelectorText">Disney Quest</span>
						</div>
						<div class="gaSelectorButton">
							<div class="gaSelectorIcon"></div>
							<span class="gaSelectorText">ESPN</span>
						</div>
						<div class="gaSelectorButton">
							<div class="gaSelectorIcon"></div>
							<span class="gaSelectorText">Blizzard Beach</span>
						</div>
						<div class="gaSelectorButton">
							<div class="gaSelectorIcon"></div>
							<span class="gaSelectorText">Typhoon Lagoon</span>
						</div>
						<div class="gaSelectorButton">
							<div class="gaSelectorIcon"></div>
							<span class="gaSelectorText">Alpha Lab</span>
						</div>
					</div>
				</div>
			</div>



<!-- ********************************************* -->
<!-- Reader Utility page -->

			<div id="readerUtilityPage" class="utilitypage" data-role="page" data-overlay-theme="a" data-theme="c" style="max-width:400px;">
				<script>
					var myPage = $('#readerUtilityPage');
					
					myPage.on('pageinit', function (event) {
						xConnect.readerUtilityPage.pageInit();
					});
				</script>
				<div data-role="header" data-position="fixed">
					<a data-rel="back" href="#" data-icon="arrow-l">Back</a>
					<h1>TPID</h1>
				</div>
				<div class='gaContent' data-role="content">
					<div class="utilityheader" id="readerutilityreader">Touch Point Utilities</div>
					<ul data-role="listview" class="gaList">
						<li class='gaListItem'>
							<a class="utility gaListItem" data-xconnect-utility="scheduleMaintenance" href="#utilitycommentpage" data-theme="b">
								<img class='buttonicon gaIcon' src='img/reader-Schedulemaint.png'/>
								<span class="firstlineutility gaLeftText">Schedule Maintenance</span>
							</a>
						</li>
						<li class='gaListItem'>
							<a class="utility gaListItem" data-xconnect-utility="scheduleBioMaintenance" href="#utilitycommentpage" data-theme="b">
								<img class='buttonicon gaIcon' src='img/reader-Schedulebio.png'/>
								<span class="firstlineutility gaLeftText">Schedule Bio Maintenance</span>
							</a>
						</li>
						<li class='gaListItem'>
							<a class="utility gaListItem" data-xconnect-utility="shutdownReader" href="#utilitycommentpage" data-theme="b">
								<img class='buttonicon gaIcon' src='img/reader-Shutdown.png'/>
								<span class="firstlineutility gaLeftText">Take Out of Service</span>
							</a>
						</li>
					</ul>
					<div class="utilitydivider" id="readerutilitylocation">Location Utilities</div>
					<ul data-role="listview" class="gaList">
						<li class='gaListItem' id="readerUtilityCloseLocationButton">
							<a class="utility gaListItem" data-xconnect-utility="closeLocation" href="#utilitycommentpage" data-theme="b">
								<img class='buttonicon gaIcon' src='img/location-Close.png'/>
								<span class="firstlineutility gaLeftText">Close Location</span>
							</a>
						</li>
					</ul>
				</div>
			</div>


<!-- ********************************************* -->
<!-- Greeter Utility page -->

			<div id="greeterutilitypage" class="utilitypage" data-role="page" data-overlay-theme="a" data-theme="c" style="max-width:400px;">
				<div data-role="header" data-position="fixed">
					<a data-rel="back" href="#" data-icon="arrow-l">Back</a>
					<h1>Greeter</h1>
				</div>
				<div class="gaContent" data-role="content">
					<div class="utilityheader">Greeter Utilities: </div>
					<ul class='gaList' data-role="listview">
						<li class='gaListItem'>
							<a class="utility gaListItem" data-xconnect-utility="closeAllLocations" href="#utilitycommentpage" data-theme="b">
								<img class='buttonicon gaIcon' src='img/location-CloseAll.png'/>
								<span class="firstlineutility gaLeftText">Close all locations</span>
							</a>
						</li>
					</ul>
					<div id="greeterutilitydiv">
						<ul class="locationdetailsinfo gaList" id="greeterUtilityLocations" data-role="listview" data-theme="a">
							<li class='gaListItem'>
								<div class='gaListItem'>
									<img class='buttonicon gaIcon' src='img/location-Close.png'/>
									<span class='gaLeftText'>Location 134</span>
								</div>
							</li>
							<li class="gaListItem">
								<div class='gaListItem'>
									<img class='buttonicon gaIcon' src='img/location-Close.png'/>
									<span class='gaLeftText'>Location 135</span>
								</div>
							</li>
						</ul>
					</div>
				</div>
			</div>


<!-- ********************************************* -->
<!-- Reader View -->

			<div data-role="page" id="readerView">
				<script>
					$('#readerView').on('pageinit', function (event) {
						xConnect.readerView.pageInit();
					});
				</script>
				<div data-role="header" data-position="fixed">
					<a data-rel="back" href="#ignored" data-icon="arrow-l">Back</a>
					<span class="ui-title"></span>
				</div>
				<div class="gaContent" data-role="content">
					<ul class='gaList' id="greeterreadermonitorlist" data-role="listview"></ul>
				</div>
			</div>

<!-- ********************************************* -->
<!-- Utility Comment page -->

			<div data-role="page" id="utilitycommentpage">
				<div data-role="header" data-position="fixed">
					<a data-rel="back" href="#ignored" data-icon="delete">Cancel</a>
					<span class="ui-title">Notes</span>
				</div>
				<div data-role="content">
					<textarea id="utilitycomment">Comments</textarea>
					<button id="commentbutton" data-theme="b" data-inline="false">Schedule Maintenance</button>
				</div>
			</div>
			
<!-- ********************************************* -->
<!-- Venue Map page -->

			<div data-role="page" id="venueMap">
				<div data-role="header" data-position="fixed">
					<a data-rel="back" href="#ignored" data-icon="arrow-l">Back</a>
					<span class="ui-title">&nbsp;</span>
					<a href="#venueMapLegend" data-icon="arrow-r" data-iconpos="right">Legend</a>
				</div>
                <div id="mapwrapper">
                    <div class="gaMap" data-role="content">
                        <img id="venueMapImage" src="img/venue-mk.png"/>
                    </div>
                </div>
			</div>
			
<!-- ********************************************* -->
<!-- Venue Map Legend page -->

			<div data-role="page" id="venueMapLegend">
				<div data-role="header" data-position="fixed">
					<a data-rel="back" href="#ignored" data-icon="arrow-l">Back</a>
					<span class="ui-title">&nbsp;</span>
				</div>
				<div class="gaMap" data-role="content">
					<img src="img/mapLegend.png"/>
				</div>
			</div>
			
<!--  End of pages -->			
		</div>

<!-- ******************************************************** -->
<!--  TEMPLATES -->
<div style="display:none;">

<!-- Location View Header Template for Greeter Location List -->
	<ul id="locationviewheadertemplate" class="gaList" data-role="listview" data-theme="c">
	</ul>	
	
<!-- Location View Item Template for Greeter Location View -->
	<ul> <!--  dummy ul to make JSLint happy -->
	<li id="locationviewtemplate" class="gaListItem">
		<a class="gaListItem" href="#locationDetails" data-transition="none">
			<img class="gaIcon" src="img/reader68.png" alt="Location Name"/>
			<div class='gaLeftText gaHasSubScript'>
				<span data-bind="name">Location Name</span></br>
				<span class='gaSubScript' data-bind="status">Location status</span>
			</div>
			<span class="gaRightText" data-bind="castid">&nbsp;</span>
		</a>
	</li>
	</ul>
	
<!-- Combined View Header Template for Coordinator -->
	<ul> <!--  dummy ul to make JSLint happy -->
		<li id="combinedviewheadertemplate" class="gaListItem gaDivider" data-role="divider" data-theme="b">
			<span class='location gaLeftText' data-bind="location">Location Name</span><span class='cast gaRightText' data-bind='cast'>Cast</span>
		</li>
	</ul>
	
<!-- Combined View Item Template for Coordinator -->
	<ul> <!-- dummy wrapper to make JSLint happy -->
		<li id="combinedviewitemtemplate" class='combinedviewitem gaListItem'>
			<a class='gaListItem' href="#readerUtilityPage">
				<img class="readericon gaIcon" src="" data-bind='reader.icon'/>
				<div class='gaLeftText gaHasSubScript'>
					<span class="readername" data-bind="reader.name" >Touch Point Name</span><br/>
					<span class="gaSubScript" data-bind="reader.logicalState" >Touch Point state message</span>
				</div>
				<span class="guestinfo gaRightText" data-bind="reader.guest.child"></span>
			</a>
		</li>
	</ul>
		
<!-- Greeter View Item Template for Coordinator -->
	<ul> <!-- dummy wrapper to make JSLint happy -->
		<li id="greeterviewitemtemplate" class=" gaListItem greeterviewitem ui-btn ui-btn-icon-right ui-li-has-arrow ui-li ui-li-has-thumb ui-li-last ui-btn-up-c" data-corners="false" data-shadow="false" data-iconshadow="true" data-wrapperels="div" data-icon="arrow-r" data-iconpos="right" data-theme="c">
			<div class="ui-btn-inner ui-li">
				<div class="ui-btn-text">
					<a href="#greeterutilitypage" class="gaListItem ui-link-inherit">
						<img class="gaIcon greetericon ui-li-thumb" src="img/greeter-icon.png">
						<span class="gaLeftText greetername" data-bind="name">Cast Name</span>
					</a>
				</div>
				<span class="ui-icon ui-icon-arrow-r ui-icon-shadow">&nbsp;</span>
			</div>
		</li>
	</ul>

<!-- Greeter Utility Item Template for Coordinator -->
	<ul> <!-- dummy wrapper to make JSLint happy -->
		<li class="gaListItem" id="greeterutilityitemtemplate">
			<div class='gaListItem'>
				<img class='buttonicon gaIcon' src='img/location-Close.png'/>
				<span class='gaLeftText' data-bind="name">Location 134</span>
			</div>
		</li>
	</ul>

<!-- Reader view item template -->
	<ul> <!-- dummy ul wrapper to make JSLint happy -->
		<li class="readeritem gaListItem" id="readeritemtemplate">
			<div class='gaListItem'>
				<img class="readerstateicon gaIcon" src="img/reader-Ready.png" data-bind='reader.icon'/>
				<div class='gaLeftText gaHasSubScript'>
					<span class="readername" data-bind="reader.name" >Touch Point Name</span><br/>
					<span class="gaSubScript" data-bind="reader.logicalState">Touch Point state</span><br>
					<span class="gaSubScript" data-bind="reader.celebrations">Touch Point state</span>
				</div>
				<div class='gaRightText gaHasSubScript'>
					<span class="guestinfo" data-bind="reader.guest.child"></span><br/>
					<span class="gaSubScript" data-bind="reader.guest.name">Guest Name</span>
				</div>
				<div class="readerBlueButtons" data-bind="reader.blueButtons">
					<button class="retryButton" data-theme="b">Retry</button>
					<button class="redirectButton" data-theme="b">Redirect</button>
				</div>
			</div>
		</li>
	</ul>

	<ul> <!-- dummy ul wrapper to make JSLint happy -->
		<li class="readeritem gaListItem" id="readeritem2uptemplate">
			<div class='gaListItem'>
				<div class='gaCenter gaHeader' data-bind='reader.name'>Touch Point Name</div>
				<img style="float: left;" data-bind='reader.celebrations' class="gaIcon gaOff gaMediumIcon" src="img/nocelebration120.png" />
				<img style="float: right;" data-bind='reader.guest.child' class="gaIcon gaOff gaMediumIcon" src="img/nochild120.png" />
				<img class="gaIcon gaLargeIcon" data-bind="reader.icon" src="img/reader-Ready256.png" />
				<div class='gaLeftText gaTight'>
					<span>Status: </span>
					<span data-bind="reader.logicalState">Touch Point state</span>
				</div>
				<div style="clear:left;"></div>
				<div class='gaLeftText gaTight'>
					<span>Guest: </span>
					<span data-bind="reader.guest.name">Guest Name</span>
				</div>
				<div class="readerBlueButtons gaAlwaysThere" data-bind="reader.blueButtons">
					<button class="retryButton" data-theme="b">Retry</button>
					<button class="redirectButton" data-theme="b">Redirect</button>
				</div>
			</div>
		</li>
	</ul>

<!-- location detail reader item template -->
	<ul> <!-- dummy ul wrapper to make JSLint happy -->
		<li class="locationdetailreader gaListItem" id="locationdetailreaderitemtemplate">
			<div class="gaListItem">
				<img class="readerstateicon gaIcon" src="img/reader-Ready.png" data-bind='reader.icon'/>
				<div class='gaLeftText gaHasSubScript'>
					<span class="readername" data-bind="reader.name" >Touch Point Name</span><br/>
					<span class="gaSubScript" data-bind="reader.tor" >TOR</span>
				</div>
			</div>
		</li>
	</ul>

	
</div>

<script>
xConnect.binder = function (template) {
	return function(data) {
		// assume the filter matches a single template
		var clone = $(template).clone();
		if( data ) {
			if( data.id ) {
				clone.prop( 'id', data.id);
			} else {
				// removing an attribute that does not exist is not an error
				clone.removeAttr("id");
			}
			clone.find( '*[data-bind]' ).each( function(k, element) {
				var fs = element.firstChild;
				var prop = $(element).attr('data-bind');
				// if data has a prop attribute, set fs.nodeValue to it.
				if (data.hasOwnProperty(prop)) {
					fs.nodeValue = data[prop];
				}
			});
		}
		
		return clone;
	};
};
</script>

	</body>

</html>
