package com.disney.xband.xbrc.lib.model;

import java.net.SocketException;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import java.util.Properties;

import org.apache.log4j.Logger;

import com.disney.xband.common.lib.Config;
import com.disney.xband.common.lib.Configuration;
import com.disney.xband.common.lib.MetaData;
import com.disney.xband.common.lib.PersistName;
import com.disney.xband.xbrc.lib.idms.IDMSResolver;
import com.disney.xband.xbrc.lib.net.NetInterface;

@PersistName("ControllerInfo")
public class ControllerInfo extends Configuration
{
	public static transient Logger logger = Logger
			.getLogger(ControllerInfo.class);

	@Override
	protected void initHook(Connection conn) {}
	 
	@PersistName("model")
	@MetaData(name = "model", description = "Facility model", defaultValue = "com.disney.xband.xbrc.attractionmodel.CEP", updatable = false)
	private String model;

	@PersistName("venue")
	@MetaData(name = "venue", description = "Facility id", defaultValue = "xBRC")
	private String sVenueName;
	
	@PersistName("name")
	@MetaData(name = "name", description = "Facility name", defaultValue = "xBRC")
	private String name;

	@PersistName("verbose")
	@MetaData(name = "verbose", description = "Enable or disable verbose level logging", defaultValue = "false")
	private boolean bVerbose;

	@PersistName("eventdumpfile")
	@MetaData(name = "eventdumpfile", description = "Contains all reader events", defaultValue = "/var/log/xbrc/eventdump.txt")
	private String sEventDumpFile;
	
	@PersistName("eventdumpmaxsizemb")
	@MetaData(name = "eventdumpmaxsizemb", min = "1", defaultValue = "1000", description="Maximum eventdump file size in megabytes")
	private int eventdumpmaxsizemb;
	
	@PersistName("eventdumpmaxfiles")
	@MetaData(name = "eventdumpmaxfiles", min = "1", defaultValue = "30", description="Maximum eventdump file size in megabytes")
	private int eventdumpmaxfiles;

	@PersistName("jmsretryperiod")
	@MetaData(name = "jmsretryperiod", description = "How often (in milliseconds) to try to reconnect to the JMS broker", min = "0", defaultValue = "60000")
	private int cmsecJMSRetry;

	@PersistName("xviewurl")
	@MetaData(name = "xviewurl", defaultValue="http://localhost:8090/Xview",description = "URL for sending RESTful request to IDMS")
	private String sxViewURL;

	@PersistName("discoverynetprefix")
	@MetaData(name = "discoverynetprefix", description="Ip address prefix (for example 10.) allowing to choose from multiple network interfaces. Used to find own IP address.")
	private String sDiscoveryNetPrefix;

	@PersistName("watchedbandtimeout")
	@MetaData(name = "watchedbandtimeout", min = "0", description = "The xBRC `UI Signal strength for XBand ID` page monitors band events. The events are accumulated on the xBRC and kept around for the number of seconds specified by this timeout.", defaultValue = "180")
	private int csecWatchedBandTimeout;

	@PersistName("updatestreamurl")
	@MetaData(name = "updatestremurl", description="Specifies the HTTP endpoint where to post messages generated by the xBRC")
	private String sUpdateStreamURL;

	@PersistName("ownIPPrefix")
	@MetaData(name = "ownIPPrefix", defaultValue = "192.", description="In solo mode, when VIP address is not used, the xBRC uses this network prefix to discover its own IP address to which readers will post events.")
	private String ownIpPrefix;

	@PersistName("httpport")
	@MetaData(name = "httpport", description = "HTTP port this controller is listening on", min = "0", defaultValue = "8080", updatable = false)
	private int nHttpPort;

	@PersistName("httpsport")
	@MetaData(name = "httpsport", description = "HTTPS port this controller is listening on", min = "0", allowNull = true, defaultValue = "0")
	private int nHttpsPort;

	@PersistName("bioImageCapure")
	@MetaData(name = "bioimagecapture", defaultValue = "false", description = "If 'true' the diagnostic bio images are captured by the reader.")
	private boolean bioImageCapure;

	@PersistName("RFIDTestMode")
	@MetaData(name = "RFIDTestMode", defaultValue = "false", description = "If 'true' the reader enters loopback mode automatically scanning RFID every few seconds.")
	private boolean RFIDTestMode;
	
	@PersistName("securetapid")
	@MetaData(name = "securetapid", defaultValue = "true", description = "Set to true to ask the reader to send secure tap id's.")
	private boolean secureTapId;

	@PersistName("setReaderTime")
	@MetaData(name = "setReaderTime", defaultValue = "true", description="When set to true, the xBRC will use the /time REST call to synchronize the reader time with its own time")
	private boolean setReaderTime;

	@PersistName("readerhellotimeoutsec")
	@MetaData(name = "readerhellotimeoutsec", defaultValue = "90", description="The xBRC will consider a reader as 'Not Responding` if the Hello message is not received for the specified number of seconds.")
	private long readerHelloTimeoutSec;

	@PersistName("readerdatasendperiod_msec")
	@MetaData(name = "readerdatasendperiod_msec", min = "25", defaultValue = "100", description = "Determines the interval (in msec) readers (tap and long-range) send their data")
	private int cmsecReaderDataSendPeriod;

	@PersistName("eventprocessingperiod_msec")
	@MetaData(name = "eventprocessingperiod_msec", min = "50", defaultValue = "200", description="The number of milliseconds designated for an xBRC event processing cycle. The xBRC will wait before statring a new processing cycle for the ammount of time not used in the previous processing cycle.")
	private int cmsecEventProcessingPeriod;

	@PersistName("maxreadsbeforepurge")
	@MetaData(name = "maxreadsbeforepurge", defaultValue = "8", description = "Determines how many long range events are cached for a particular message "
			+ "sequence number in order to support the 'power level' user interface")
	private int maxReadsBeforePurge;

	@PersistName("singulationalgorithm")
	@MetaData(name = "singulationalgorithm", defaultValue = "max", description = "Set to 'max' or 'mean'. Controls the singulation algorithm used by the xBRC")
	private String sSingulationAlgorithm;

	@PersistName("readerhttptimeout_msec")
	@MetaData(name = "readerhttptimeout_msec", defaultValue = "3000", description = "Number of milliseconds that xBRC waits before timing out when writing to xBRs and xFPEs")
	private int msecReaderHttpTimeout;

	@PersistName("updatestreamhttptimeout_msec")
	@MetaData(name = "updatestreamhttptimeout_msec", defaultValue = "3000", description = "Number of milliseconds that xBRC waits before timing out when writing to upstream apps via HTTP")
	private int msecUpdateStreamHttpTimeout;

	@PersistName("perfmetricsperiod")
	@MetaData(name = "perfmetricsperiod", defaultValue = "300", description = "How often (in seconds) xBRC performance metrics are cleared and metrics calculated")
	private int csecPerfMetricsPeriod;

	@PersistName("messagestorageperiod")
	@MetaData(name = "messagestorageperiod", defaultValue = "3600", description = "How long (in seconds) the xBRC should store messages")
	private int csecMessageStoragePeriod;

	@PersistName("reducedataslicing")
	@MetaData(name = "reducedataslicing", defaultValue = "true", description = "Set to 'true' to use heuristics to reduce data slicing problems.")
	private boolean bReduceDataSlicing;

	@PersistName("idmscachetime_sec")
	@MetaData(name = "idmscachetime_sec", defaultValue = "1800", description = "Duration (seconds) that IDMS results should be cached")
	private int csecIDMSCacheTimeout;

	@PersistName("adjusteventtimes")
	@MetaData(name = "adjusteventtimes", defaultValue = "true", description = "Set to true to base event times on xBRC time")
	private boolean bAdjustEventTimes;

	@PersistName("wwwdir")
	@MetaData(name = "wwwdir", description = "Base directory accessible via http allowing read access to all files", defaultValue = "/usr/share/xbrc/www")
	private String wwwdir;
	
	@PersistName("webserverthreadcount")
	@MetaData(name = "webserverthreadcount", defaultValue = "32", description = "Total number of threads used by the xBRC web server to service REST requests.")
	private int webserverthreadcount;
	
	@PersistName("vipaddress")
	@MetaData(name = "vipaddress", defaultValue="#", description = "BigIP virtual name or address of xBRC")
	private String vipAddress;
	
	@PersistName("updatestreamcorepoolsize")
	@MetaData(name = "updatestreamcorepoolsize", defaultValue = "16", description = "Core thread pool size for sending update stream messages.")
	private int updatestreamcorepoolsize;
	
	@PersistName("updatestreammaxpoolsize")
	@MetaData(name = "updatestreammaxpoolsize", defaultValue = "80", description = "Max thread pool size for sending update stream messages.")
	private int updatestreammaxpoolsize;
	
	@PersistName("updatestreamqueuesize")
	@MetaData(name = "updatestreamqueuesize", defaultValue = "1000", description = "Queued jobs for the thread pool size sending update stream messages.")
	private int updatestreamqueuesize;

    @PersistName("updatestreamuseasync")
    @MetaData(name = "updatestreamuseasync", defaultValue = "true", description = "Use asynchronous threading for delivering update stream message.")
    private boolean updateStreamUseAsync;
    
    @PersistName("updatestreambatchsize")
    @MetaData(name="updatestreambatchsize", defaultValue= "1", description = "Maximum number of messages to send to update stream in each POST.")
    private int updateStreamBatchSize;
    
    @PersistName("updatestreamintervalms")
    @MetaData(name="updatestreamintervalms", defaultValue= "200", description = "How often to check the Messages table for new messages to send.")
    private int updateStreamIntervalMs;
    
    @PersistName("readertimeprecisionms")
	@MetaData(name = "readertimeprecisionms", defaultValue = "1000", description = "Set reader time if it is off more than the specified number of milliseconds.")
	private long readertimeprecisionms;
    
    @PersistName("updatestreamfasttaps")
    @MetaData(name = "updatestreamfasttaps", defaultValue = "false", description = "Bypass IDMS lookups and other processing when sending TAP events to update stream.")
    private boolean updateStreamFastTaps;
    
    @PersistName("fasttapurl")
	@MetaData(name = "fastapurl", defaultValue="", description = "HTTP REST URL to which fast TAP events are POSTed, bypassing IDMS lookups and other processing in the xBRC.")
	private String fastTapUrl;
    
    @PersistName("readerupdatestreams")
	@MetaData(name="readerupdatestreams", defaultValue="",  description="Pipe separated list of URL where the readers are to post events.")
	private List<String> readerUpdateStreams;

	@PersistName("statesaveperiod_msec")
	@MetaData(name = "statesaveperiod_msec", min="0", defaultValue="1000", description = "How frequently (msec) the xBRC state should be saved.")
	private int cmsecStateSavePeriod;
	
	@PersistName("preferredguestidtype")
	@MetaData(name="preferredguestidtype", description="Additional guest id type to be provided in generated messages.")
	private String sPreferredGuestIdType;
	
	@PersistName("transmitxbrperiod_msec")
	@MetaData(name="transmitxbrperiod_msec", min="100", defaultValue="2000", 
					description="How frequently (msec) transmit xBRs should be give new instructions.")
	private long cmsecTransmitXbrPeriod;
	
	@PersistName("updateStreamPostRetry_sec")
	@MetaData(name="updateStreamPostRetry_sec", min="1", defaultValue="60", 
					description="How long to wait after a failed post to the updatestream URL before a retry attempt is made.")
	private long updateStreamPostRetry_sec;
	
	@PersistName("updateStreamMessageTypes")
	@MetaData(name = "updateStreamMessageTypes", description = "Space separated list of messsage types to post to update stream. Use * for all types.", defaultValue = "*")
	private String updateStreamMessageTypes;

    @PersistName("successSequence")
    @MetaData(name="successSequence", defaultValue="success", description="The reader media sequence name played in response to successful guest interaction")
    private String sSuccessSequence;
    
	@PersistName("successTimeout_msec")
	@MetaData(name = "successTimeout_msec", defaultValue = "2500", description = "Duration in milliseconds of the success sequence. 0 = no timeout")
	private long successTimeout;

    @PersistName("failureSequence")
    @MetaData(name="failureSequence", defaultValue="exception", description="The reader media sequence played in response to system error while processing guest interaction")
    private String sFailureSequence;
    
	@PersistName("failureTimeout_msec")
	@MetaData(name = "failureTimeout_msec", defaultValue = "0", description = "Duration in milliseconds of the failure sequence. 0 = no timeout")
	private long failureTimeout;

    @PersistName("errorSequence")
    @MetaData(name="errorSequence", defaultValue="exception", description="The reader media sequence played in response to unsuccessful guest interaction (for example no guest entitlement).")
    private String sErrorSequence;
    
	@PersistName("errorTimeout_msec")
	@MetaData(name = "errorTimeout_msec", defaultValue = "2000", description = "Duration in milliseconds of the error sequence. 0 = no timeout")
	private long errorTimeout;
	
	@PersistName("tapSequence")
	@MetaData(name="tapSequence", defaultValue="thinking", description="Reader media sequence played in response to a guest tap before success or failure sequence is played.")
	private String tapSequence;
	    	
	@PersistName("tapTimeout_msec")
	@MetaData(name = "tapTimeout_msec", defaultValue = "10000", description = "Duration in milliseconds of the tap sequence. 0 = no timeout")
	private long tapTimeout;

    @PersistName("idleSequence")
    @MetaData(name="idleSequence", defaultValue="idle", description="Reader media sequence shown on the reader when reader is idle")
    private String sIdleSequence;
    
    @PersistName("enableHA")
    @MetaData(name="enableHA", defaultValue="true", description="Enable master/slave high-availability support")
    private boolean haEnabled;

    @PersistName("readerEventBufferSize")
    @MetaData(name = "readerEventBufferSize", defaultValue = "200", description = "Total number of events to buffer on the reader.")
    private long readerEventBufferSize;

    @PersistName("readerPowerOnTime")
    @MetaData(name="readerPowerOnTime", defaultValue="", description="Date string (yyyy-MM-dd'T'HH:mm:ss.SSS) (only time is significant, yyyy-MM-dd will be ignored) representing the time when readers are to be powered on. Empty = always on")
    private String readerPowerOnTime;

    @PersistName("readerPowerOffTime")
    @MetaData(name="readerPowerOffTime", defaultValue="", description="Date string (yyyy-MM-dd'T'HH:mm:ss.SSS) (only time is significant, yyyy-MM-dd will be ignored) representing the time when readers are to be powered off. Empty = always on")
    private String readerPowerOffTime;

    @PersistName("readerPowerOffPeriod")
    @MetaData(name="readerPowerOffPeriod", defaultValue="30", min="1", max="120", description="Duration in minutes that a reader sleeps before waking up to check in with the xBRC before (potentially) going back to sleep.")
    private int readerPowerOffPeriod;

    @PersistName("readerPowerOverrideDate")
    @MetaData(name="readerPowerOverrideDate", defaultValue="", description="Date string (yyyy-MM-dd'T'HH:mm:ss.SSS) representing the date and time when readers are to be powered on for a limited duration.", updatable = false)
    private String readerPowerOverrideDate;

    @PersistName("readerPowerOverrideMinutes")
    @MetaData(name="readerPowerOverrideMinutes", defaultValue="0", description="Time in minutes the readerPowerOverride is valid.", updatable = false)
    private int readerPowerOverrideMinutes;


    @PersistName("readerBatteryLevelYellow")
    @MetaData(name="readerBatteryLevelYellow", defaultValue="40", description="Battery Level at/below which causes the Reader status to become yellow.")
    private int readerBatteryLevelYellow;

    @PersistName("readerBatteryLevelRed")
    @MetaData(name="readerBatteryLevelRed", defaultValue="20", description="Battery Level at/below which causes the Reader status to become red.")
    private int readerBatteryLevelRed;


    @PersistName("readerTemperatureMaxRed")
    @MetaData(name="readerTemperatureMaxRed", defaultValue="2000", description="Temperature(C) at/above to cause the Reader status to become red.")
    private int readerTemperatureMaxRed;

    @PersistName("readerTemperatureMinRed")
    @MetaData(name="readerTemperatureMinRed", defaultValue="-100", description="Temperature(C) at/below to cause the Reader status to become red.")
    private int readerTemperatureMinRed;

    @PersistName("readerTemperatureMaxYellow")
    @MetaData(name="readerTemperatureMaxYellow", defaultValue="2000", description="Temperature(C) at/above to cause the Reader status to become yellow.")
    private int readerTemperatureMaxYellow;

    @PersistName("readerTemperatureMinYellow")
    @MetaData(name="readerTemperatureMinYellow", defaultValue="-100", description="Temperature(C) at/below to cause the Reader status to become yellow.")
    private int readerTemperatureMinYellow;
    
    @PersistName("guestidentifiertypes")
	@MetaData(name="guestidentifiertypes", choices="dme-link-id,xbms-link-id,xid,swid,transactional-guest-id,gff-bog-link-id,admission-link-id,payment-link-id,media-link-id,leveln-link-id,bog-xedc-link-id,bog-link-id,fidelio-link-id,seaware-link-id", defaultValue="xbms-link-id|xid|gxp-link-id|swid|fidelio-link-id|seaware-link-id",  description="Pipe separated list of guest ID types in order of preference to send in JMS messages.")
	private List<String> guestIdentifierTypes;

    @PersistName("diskspacemonitorpath")
    @MetaData(name="diskspacemonitorpath", defaultValue="/", description="Specifies which directory to monitor for low disk space")
    private String diskSpaceMonitorPath;

    @PersistName("diskspacewarnmb")
    @MetaData(name="diskspacewarnmb", defaultValue="500", description="Show a warning when disk space falls below the specified number of megabytes")
    private long diskSpaceWarnMb;
    
    @PersistName("diskspacefatalmb")
    @MetaData(name="diskspacefatalmb", defaultValue="200", description="Show a fatal error when disk space falls below the specified number of megabytes")
    private long diskSpaceFatalMb;
    
    @PersistName("uselog4jforeventdump")
    @MetaData(name="uselog4jforeventdump", defaultValue="true", description="Whether to use log4j system for eventdump.txt logging")
    private boolean uselog4jforeventdump;
    
    @PersistName("eventdumpbuffersize")
    @MetaData(name="eventdumpbuffersize", defaultValue="4000", description="If using log4j system for eventdump.txt logging then the xBRC buffers in memory the specified number of lines in order to provide the /ekg REST functionality")    
    private int eventdumpBufferSize;
    
    @PersistName("readertestbandtype")
    @MetaData(name="readertestbandtype", defaultValue="ReaderTest", description="Band type used to initiate a test on a TAP reader.")
    private String readerTestBandType;
    
    @PersistName("readertestvolume")
    @MetaData(name="readertestvolume", defaultValue="0", description="If set to value other than 0, this volume will override the volume specified per each action when playing a reader test.")    
    private int readerTestVolume;

    public void setVenue(String sVenueName)
	{
		this.sVenueName = sVenueName;
	}

	public String getVenue()
	{
		return sVenueName;
	}

	public int getHttpPort()
	{
		return nHttpPort;
	}

	public void setHttpPort(int nHttpPort)
	{
		this.nHttpPort = nHttpPort;
	}

	public int getHttpsPort()
	{
		return nHttpsPort;
	}

	public void setHttpsPort(int nHttpsPort)
	{
		this.nHttpsPort = nHttpsPort;
	}
	
	public int getPort()
	{
		if (isSLLEnabled())
			return nHttpsPort;
		
		return nHttpPort;
	}

	public boolean isSLLEnabled()
	{
		return nHttpsPort > 0;
	}

	public boolean getVerbose()
	{
		return this.bVerbose;
	}

	public void setVerbose(boolean bVerbose)
	{
		this.bVerbose = bVerbose;
	}

	public void setEventDumpFile(String sEventDumpFile)
	{
		this.sEventDumpFile = sEventDumpFile;
	}

	public String getEventDumpFile()
	{
		return sEventDumpFile;
	}

	public void setJMSRetryPeriod(int cmsec)
	{
		this.cmsecJMSRetry = cmsec;
	}

	public int getJMSRetryPeriod()
	{
		return this.cmsecJMSRetry;
	}

	public int getPerfMetricsPeriod()
	{
		return this.csecPerfMetricsPeriod;
	}

	public void setPerfMetricsPeriod(int csecPerfMetricsPeriod)
	{
		this.csecPerfMetricsPeriod = csecPerfMetricsPeriod;
	}

	public String getxViewURL()
	{
		return this.sxViewURL;
	}

	public void setxViewURL(String sURL)
	{
		this.sxViewURL = sURL;
	}

	public String getDiscoveryNetPrefix()
	{
		return sDiscoveryNetPrefix;
	}

	public void setDiscoveryNetPrefix(String sDiscoveryNetPrefix)
	{
		this.sDiscoveryNetPrefix = sDiscoveryNetPrefix;
	}

	public String getModel()
	{
		return model;
	}

	public String getModelName()
	{
		// parse something like com.disney.xband.xbrc.parkentrymodel.CEP
		int iStart = "com.disney.xband.xbrc.".length();
		int iEnd = model.length() - ".CEP".length();
		return model.substring(iStart, iEnd);
	}

	public void setModel(String model)
	{
		this.model = model;
	}

	public void setWatchedBandTimeout(int nSec)
	{
		this.csecWatchedBandTimeout = nSec;
	}

	public int getWatchedBandTimeout()
	{
		return csecWatchedBandTimeout;
	}

	public String getUpdateStreamURL()
	{
		return this.sUpdateStreamURL;
	}

	public void setUpdateStreamURL(String sURL, Connection conn)
	{
		// TODO: reconsider whether we need to remember this
		PreparedStatement stmt = null;

		this.sUpdateStreamURL = sURL;
		try
		{
			// save to database
			if (conn != null)
			{
				String sSQL = "UPDATE Config SET Value=? WHERE Property='updatestreamurl' and class='ControllerInfo'";
				stmt = conn.prepareStatement(sSQL);
				stmt.setString(1, this.sUpdateStreamURL);
				stmt.executeUpdate();
			}
		}
		catch (Exception e)
		{
			logger.error("!! Error updating Config table: ", e);
		}
		finally
		{
			try
			{
				if (stmt != null)
					stmt.close();
			}
			catch (Exception e)
			{
			}
		}
	}

	public String getOwnIpPrefix()
	{
		return ownIpPrefix;
	}

	public void setOwnIpPrefix(String ownIPPrefix)
	{
		this.ownIpPrefix = ownIPPrefix;
	}

	public boolean isRFIDTestMode()
	{
		return RFIDTestMode;
	}

	public void setRFIDTestMode(boolean rFIDTestMode)
	{
		RFIDTestMode = rFIDTestMode;
	}

	public String getXbrcURL()
	{
		// get own ip address respecting address preferences
		Collection<String> ownIP = null;
		try
		{
			ownIP = NetInterface.getOwnIpAddress(this.ownIpPrefix);

			// if nothing with the desired prefix, go for anything at all!
			if (ownIP.isEmpty())
				ownIP = NetInterface.getOwnIpAddress(null);
		}
		catch (SocketException e)
		{
			logger.error("Exception while trying to get own IP address", e);
		}

		if (ownIP.isEmpty())
		{
			logger.error("Failed to get own IP address with prefix "
					+ this.ownIpPrefix);
			return null;
		}

		// compose URL
		if (this.nHttpsPort != 0)
			return "https://" + ownIP.iterator().next() + ":"
					+ Integer.toString(this.nHttpsPort);
		else
			return "http://" + ownIP.iterator().next() + ":"
					+ Integer.toString(this.nHttpPort);
	}
	
	public String getXbrcVipURL()
	{
		String vipAddress = getVipAddress();
		if (vipAddress!=null && vipAddress.length()>0 && !vipAddress.startsWith("#"))
		{
			int nPort = getHttpsPort();
			if (nPort!=0)
				vipAddress = "https://" + vipAddress + ":" + nPort;
			else
			{
				nPort = getHttpPort();
				vipAddress = "http://" + vipAddress + ":" + nPort;
			}
			return vipAddress;
		}
		else
		{
			return getXbrcURL();
		}
	}

	public boolean isSetReaderTime()
	{
		return setReaderTime;
	}

	public void setSetReaderTime(boolean setReaderTime)
	{
		this.setReaderTime = setReaderTime;
	}

	public long getReaderHelloTimeoutSec()
	{
		return readerHelloTimeoutSec;
	}

	public void setReaderHelloTimeoutSec(long readerHelloTimeoutSec)
	{
		this.readerHelloTimeoutSec = readerHelloTimeoutSec;
	}

	public int getReaderDataSendPeriod()
	{
		return cmsecReaderDataSendPeriod;
	}

	public void setReaderDataSendPeriod(int cmsecReaderDataSendPeriod)
	{
		this.cmsecReaderDataSendPeriod = cmsecReaderDataSendPeriod;
	}

	public int getEventProcessingPeriod()
	{
		return cmsecEventProcessingPeriod;
	}

	public void setEventProcessingPeriod(int cmsecEventProcessingPeriod)
	{
		this.cmsecEventProcessingPeriod = cmsecEventProcessingPeriod;
	}

	public int getMaxReadsBeforePurge()
	{
		return maxReadsBeforePurge;
	}

	public void setMaxReadsBeforePurge(int maxReadsBeforePurge)
	{
		this.maxReadsBeforePurge = maxReadsBeforePurge;
	}

	public String getSingulationAlgorithm()
	{
		return this.sSingulationAlgorithm;
	}

	public void setSingulationAlgorithm(String sSingulationAlgorithm)
	{
		this.sSingulationAlgorithm = sSingulationAlgorithm;
	}

	public void setReaderHttpTimeout(int msecReaderHttpTimeout)
	{
		this.msecReaderHttpTimeout = msecReaderHttpTimeout;
	}

	public int getReaderHttpTimeout()
	{
		return this.msecReaderHttpTimeout;
	}

	public void setUpdateStreaHttpTimeout(int msecUpdateStreamHttpTimeout)
	{
		this.msecUpdateStreamHttpTimeout = msecUpdateStreamHttpTimeout;
	}

	public int getUpdateStreamHttpTimeout()
	{
		return this.msecUpdateStreamHttpTimeout;
	}

	public int getMessageStoragePeriod()
	{
		return this.csecMessageStoragePeriod;
	}

	public void setMessageStoragePeriod(int csecMessageStoragePeriod)
	{
		this.csecMessageStoragePeriod = csecMessageStoragePeriod;
	}

	public boolean getReduceDataSlicing()
	{
		return bReduceDataSlicing;
	}

	public void setReduceDataSlicing(boolean bReduceDataSlicing)
	{
		this.bReduceDataSlicing = bReduceDataSlicing;
	}

	public int getIDMSCacheTimeout()
	{
		return csecIDMSCacheTimeout;
	}

	public void setIDMSCacheTimeout(int csecIDMSCacheTimeout)
	{
		this.csecIDMSCacheTimeout = csecIDMSCacheTimeout;
	}

	public boolean isAdjustEventTimes()
	{
		return bAdjustEventTimes;
	}

	public void setAdjustEventTimes(boolean bAdjustEventTimes)
	{
		this.bAdjustEventTimes = bAdjustEventTimes;
	}

	public String getWwwdir()
	{
		return wwwdir;
	}

	public void setWwwdir(String wwwdir)
	{
		this.wwwdir = wwwdir;
	}

    public boolean isBioImageCapure()
	{
		return bioImageCapure;
	}

	public void setBioImageCapure(boolean bioImageCapure)
	{
		this.bioImageCapure = bioImageCapure;
	}
	
	public long getTransmitXbrPeriod()
	{
		return cmsecTransmitXbrPeriod;
	}

	public void setTransmitXbrPeriod(long cmsecTransmitXbrPeriod)
	{
		this.cmsecTransmitXbrPeriod = cmsecTransmitXbrPeriod;
	}

	public int getStateSavePeriod()
	{
		return cmsecStateSavePeriod;
	}
	
	public void setStateSavePeriod(int cmsecStateSavePeriod)
	{
		this.cmsecStateSavePeriod = cmsecStateSavePeriod;
	}

	public long getUpdateStreamPostRetry_sec()
	{
		return updateStreamPostRetry_sec;
	}

	public void setUpdateStreamPostRetry_sec(long updateStreamPostRetry_sec)
	{
		this.updateStreamPostRetry_sec = updateStreamPostRetry_sec;
	}

	public void processConfigurationTable(Connection conn, Properties prop)
	{
		try
		{
			Config config = Config.getInstance();

			// read property/value pairs from the Config table
			config.read(conn, this);
		}
		catch (Exception e)
		{
			logger.error("!! Error processing configuration table in database: "
					+ e);
		}

		// override (some) database settings with property file
		if (prop.getProperty("verbose") != null)
			setVerbose(prop.getProperty("verbose").compareTo("true") == 0);
		if (prop.getProperty("httpport") != null)
			setHttpPort(Integer.parseInt(prop.getProperty("httpport")));
		if (prop.getProperty("httpsport") != null)
			setHttpsPort(Integer.parseInt(prop.getProperty("httpsport")));
		if (prop.getProperty("xviewurl") != null)
			setxViewURL(prop.getProperty("xviewurl"));
		if (prop.getProperty("model") != null)
			setModel(prop.getProperty("model"));

		// May as well set this here
		IDMSResolver.INSTANCE.setIDMSUrl(getxViewURL());
		
		int secTimeout = getIDMSCacheTimeout();
		IDMSResolver.INSTANCE.setCacheTimeouts(secTimeout, secTimeout);
		
		if (!IDMSResolver.INSTANCE.isEnabled())
		{
			logger.warn("Band lookups are disabled in Config table. Band Id's will not be resolved to a guest.");
		}
		
	}

	public boolean isSecureTapId()
	{
		return secureTapId;
	}

	public void setSecureTapId(boolean secureTapId)
	{
		this.secureTapId = secureTapId;
	}

	public String getName()
	{
		return name;
	}

	public void setName(String name)
	{
		this.name = name;
	}
	
	public String getPreferredGuestIdType()
	{
		return sPreferredGuestIdType;
	}
	
	public void setPreferredGuestIdType(String sPreferredGuestIdType, Connection conn)
	{
		this.sPreferredGuestIdType = sPreferredGuestIdType;
		
		// TODO: reconsider whether we need to remember this
		PreparedStatement stmt = null;
		
		try
		{
			// save to database
			if (conn != null)
			{
				String sSQL = "UPDATE Config SET Value=? WHERE Property='preferredguestidtype' and class='ControllerInfo'";
				stmt = conn.prepareStatement(sSQL);
				stmt.setString(1, this.sPreferredGuestIdType);
				stmt.executeUpdate();
			}
		}
		catch (Exception e)
		{
			logger.error("!! Error updating Config table: ", e);
		}
		finally
		{
			try
			{
				if (stmt != null)
					stmt.close();
			}
			catch (Exception e)
			{
			}
		}

	}

	public String getUpdateStreamMessageTypes()
	{
		return updateStreamMessageTypes;
	}
	
	public List<String> getUpdateStreamMessageTypesAsList()
	{
		return Arrays.asList(updateStreamMessageTypes.split(" "));
	}

	public void setUpdateStreamMessageTypes(String updateStreamMessageTypes, Connection conn)
	{
		this.updateStreamMessageTypes = updateStreamMessageTypes;
		
		PreparedStatement stmt = null;
		try
		{
			if (conn != null)
			{
				String sSQL = "UPDATE Config SET Value=? WHERE Property='updatestreammessagetypes' and class='ControllerInfo'";
				stmt = conn.prepareStatement(sSQL);
				stmt.setString(1, this.updateStreamMessageTypes);
				stmt.executeUpdate();
			}
		}
		catch (Exception e)
		{
			logger.error("!! Error updating Config table updateStreamMessageTypes: ", e);
		}
		finally
		{
			try
			{
				if (stmt != null)
					stmt.close();
			}
			catch (Exception e)
			{
			}
		}
	}

    public String getSuccessSequence()
    {
        return sSuccessSequence;
    }

    public void setSuccessSequence(String sSuccessSequence)
    {
        this.sSuccessSequence = sSuccessSequence;
    }

    public String getFailureSequence()
    {
        return sFailureSequence;
    }

    public void setFailureSequence(String sFailureSequence)
    {
        this.sFailureSequence = sFailureSequence;
    }

    public String getErrorSequence()
    {
        return sErrorSequence;
    }

    public void setErrorSequence(String sErrorSequence)
    {
        this.sErrorSequence = sErrorSequence;
    }

    public String getsIdleSequence()
    {
        return sIdleSequence;
    }

    public void setsIdleSequence(String sIdleSequence) {
        this.sIdleSequence = sIdleSequence;
    }

	public long getSuccessTimeout()
	{
		return successTimeout;
	}

	public void setSuccessTimeout(long successTimeout)
	{
		this.successTimeout = successTimeout;
	}

	public long getFailureTimeout()
	{
		return failureTimeout;
	}

	public void setFailureTimeout(long failureTimeout)
	{
		this.failureTimeout = failureTimeout;
	}

	public long getErrorTimeout()
	{
		return errorTimeout;
	}

	public void setErrorTimeout(long errorTimeout)
	{
		this.errorTimeout = errorTimeout;
	}

	public boolean isHaEnabled()
	{
		return haEnabled;
	}

	public void setHaEnabled(boolean haEnabled)
	{
		this.haEnabled = haEnabled;
	}

	public int getWebserverthreadcount()
	{
		return webserverthreadcount;
	}

	public void setWebserverthreadcount(int webserverthreadcount)
	{
		this.webserverthreadcount = webserverthreadcount;
	}
	
	public String getVipAddress()
	{
		return vipAddress;
	}
	
	public void setVipAddress(String vipAddress)
	{
		this.vipAddress = vipAddress;
	}

	public String getTapSequence()
	{
		return tapSequence;
	}

	public void setTapSequence(String tapSequence)
	{
		this.tapSequence = tapSequence;
	}

	public long getTapTimeout()
	{
		return tapTimeout;
	}

	public void setTapTimeout(long tapTimeout)
	{
		this.tapTimeout = tapTimeout;
	}
	
	public int getUpdatestreamcorepoolsize()
	{
		return updatestreamcorepoolsize;
	}

	public void setUpdatestreamcorepoolsize(int updatestreamcorepoolsize)
	{
		this.updatestreamcorepoolsize = updatestreamcorepoolsize;
	}

	public int getUpdatestreammaxpoolsize()
	{
		return updatestreammaxpoolsize;
	}

	public void setUpdatestreammaxpoolsize(int updatestreammaxpoolsize)
	{
		this.updatestreammaxpoolsize = updatestreammaxpoolsize;
	}

	public int getUpdatestreamqueuesize()
	{
		return updatestreamqueuesize;
	}

	public void setUpdatestreamqueuesize(int updatestreamqueuesize)
	{
		this.updatestreamqueuesize = updatestreamqueuesize;
	}

    public boolean getUpdateStreamUseAsync() 
    {
        return updateStreamUseAsync;
    }

    public void setUpdateStreamUseAsync(boolean updateStreamUseAsync) 
    {
        this.updateStreamUseAsync = updateStreamUseAsync;
    }

    public long getReaderEventBufferSize() {
        return readerEventBufferSize;
    }

    public void setReaderEventBufferSize(long readerEventBufferSize) {
        this.readerEventBufferSize = readerEventBufferSize;
    }
    
	public int getUpdateStreamBatchSize()
	{
		return updateStreamBatchSize;
	}

	public void setUpdateStreamBatchSize(int updateStreamBatchSize, Connection conn)
	{
		this.updateStreamBatchSize = updateStreamBatchSize;
		
		PreparedStatement stmt = null;
		try
		{
			// save to database
			if (conn != null)
			{
				String sSQL = "UPDATE Config SET value=? WHERE property='updatestreambatchsize' and class='ControllerInfo'";
				stmt = conn.prepareStatement(sSQL);
				stmt.setString(1, Integer.toString(this.updateStreamBatchSize));
				stmt.executeUpdate();
			}
		}
		catch (Exception e)
		{
			logger.error("!! Error updating Config table: ", e);
		}
		finally
		{
			try
			{
				if (stmt != null)
					stmt.close();
			}
			catch (Exception e)
			{
			}
		}
	}

	public long getReadertimeprecisionms()
	{
		return readertimeprecisionms;
	}

	public void setReadertimeprecisionms(long readertimeprecisionms)
	{
		this.readertimeprecisionms = readertimeprecisionms;
	}

	public String getReaderPowerOnTime() {
		return readerPowerOnTime;
	}

	public void setReaderPowerOnTime(String readerPowerOnTime) {
		this.readerPowerOnTime = readerPowerOnTime;
	}

	public String getReaderPowerOffTime() {
		return readerPowerOffTime;
	}

	public void setReaderPowerOffTime(String readerPowerOffTime) {
		this.readerPowerOffTime = readerPowerOffTime;
	}

	public int getReaderPowerOffPeriod() {
		return readerPowerOffPeriod;
	}

	public void setReaderPowerOffPeriod(int readerPowerOffPeriod) {
		this.readerPowerOffPeriod = readerPowerOffPeriod;
	}

	public int getReaderBatteryLevelYellow() {
		return readerBatteryLevelYellow;
	}

	public void setReaderBatteryLevelYellow(int readerBatteryLevelYellow) {
		this.readerBatteryLevelYellow = readerBatteryLevelYellow;
	}

	public int getReaderBatteryLevelRed() {
		return readerBatteryLevelRed;
	}

	public void setReaderBatteryLevelRed(int readerBatteryLevelRed) {
		this.readerBatteryLevelRed = readerBatteryLevelRed;
	}

	public String getReaderPowerOverrideDate() {
		return readerPowerOverrideDate;
	}

	public void setReaderPowerOverrideDate(String readerPowerOverrideDate) {
		this.readerPowerOverrideDate = readerPowerOverrideDate;
	}

	public int getReaderPowerOverrideMinutes() {
		return readerPowerOverrideMinutes;
	}

	public void setReaderPowerOverrideMinutes(int readerPowerOverrideMinutes) {
		this.readerPowerOverrideMinutes = readerPowerOverrideMinutes;
	}

	public int getReaderTemperatureMaxRed() {
		return readerTemperatureMaxRed;
	}

	public void setReaderTemperatureMaxRed(int readerTemperatureMaxRed) {
		this.readerTemperatureMaxRed = readerTemperatureMaxRed;
	}

	public int getReaderTemperatureMinRed() {
		return readerTemperatureMinRed;
	}

	public void setReaderTemperatureMinRed(int readerTemperatureMinRed) {
		this.readerTemperatureMinRed = readerTemperatureMinRed;
	}

	public int getReaderTemperatureMaxYellow() {
		return readerTemperatureMaxYellow;
	}

	public void setReaderTemperatureMaxYellow(int readerTemperatureMaxYellow) {
		this.readerTemperatureMaxYellow = readerTemperatureMaxYellow;
	}

	public int getReaderTemperatureMinYellow() {
		return readerTemperatureMinYellow;
	}

	public void setReaderTemperatureMinYellow(int readerTemperatureMinYellow) {
		this.readerTemperatureMinYellow = readerTemperatureMinYellow;
	}

	public int getUpdateStreamIntervalMs() {
		return updateStreamIntervalMs;
	}

	public void setUpdateStreamIntervalMs(int updateStreamIntervalMs) {
		this.updateStreamIntervalMs = updateStreamIntervalMs;
	}

	public boolean isUpdateStreamFastTaps() {
		return updateStreamFastTaps;
	}

	public void setUpdateStreamFastTaps(boolean updateStreamFastTaps) {
		this.updateStreamFastTaps = updateStreamFastTaps;
	}

	public String getFastTapUrl() {
		return fastTapUrl;
	}

	public void setFastTapUrl(String fastTapUrl) {
		this.fastTapUrl = fastTapUrl;
	}

	public List<String> getReaderUpdateStreams() {
		return readerUpdateStreams;
	}

	public void setReaderUpdateStreams(List<String> readerUpdateStreams) {
		this.readerUpdateStreams = readerUpdateStreams;
	}
	
	public int getEventdumpmaxsizemb()
	{
		return eventdumpmaxsizemb;
	}

	public void setEventdumpmaxsizemb(int eventdumpmaxsizemb)
	{
		this.eventdumpmaxsizemb = eventdumpmaxsizemb;
	}

	public int getEventdumpmaxfiles()
	{
		return eventdumpmaxfiles;
	}

	public void setEventdumpmaxfiles(int eventdumpmaxfiles)
	{
		this.eventdumpmaxfiles = eventdumpmaxfiles;
	}

	public List<String> getGuestIdentifierTypes() {
		return guestIdentifierTypes;
	}

	public void setGuestIdentifierTypes(List<String> guestIdentifierTypes) {
		this.guestIdentifierTypes = guestIdentifierTypes;
	}

	public String getDiskSpaceMonitorPath() {
		return diskSpaceMonitorPath;
	}

	public long getDiskSpaceWarnMb() {
		return diskSpaceWarnMb;
	}

	public long getDiskSpaceFatalMb() {
		return diskSpaceFatalMb;
	}

	public void setDiskSpaceWarnMb(long diskSpaceWarnMb) {
		this.diskSpaceWarnMb = diskSpaceWarnMb;
	}

	public void setDiskSpaceFatalMb(long diskSpaceFatalMb) {
		this.diskSpaceFatalMb = diskSpaceFatalMb;
	}

	public boolean isUselog4jforeventdump() {
		return uselog4jforeventdump;
	}

	public void setUselog4jforeventdump(boolean uselog4jforeventdump) {
		this.uselog4jforeventdump = uselog4jforeventdump;
	}

	public int getEventdumpBufferSize() {
		return eventdumpBufferSize;
	}

	public void setEventdumpBufferSize(int eventdumpBufferSize) {
		this.eventdumpBufferSize = eventdumpBufferSize;
	}

	public String getReaderTestBandType() {
		return readerTestBandType;
	}

	public void setReaderTestBandType(String readerTestBandType) {
		this.readerTestBandType = readerTestBandType;
	}

	public int getReaderTestVolume() {
		return readerTestVolume;
	}

	public void setReaderTestVolume(int readerTestVolume) {
		this.readerTestVolume = readerTestVolume;
	}
}
