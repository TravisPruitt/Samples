/*
Deployment script for DBDASH

This code was generated by a tool.
Changes to this file may cause incorrect behavior and will be lost if
the code is regenerated.
*/

GO
SET ANSI_NULLS, ANSI_PADDING, ANSI_WARNINGS, ARITHABORT, CONCAT_NULL_YIELDS_NULL, QUOTED_IDENTIFIER ON;

SET NUMERIC_ROUNDABORT OFF;


GO
:setvar DatabaseName "DBDASH_Master"
:setvar DefaultFilePrefix "DBDASH_Master"
:setvar DefaultDataPath "D:\mssql\db_data\"
:setvar DefaultLogPath "E:\mssql\db_logs\"

GO
:on error exit
GO
/*
Detect SQLCMD mode and disable script execution if SQLCMD mode is not supported.
To re-enable the script after enabling SQLCMD mode, execute the following:
SET NOEXEC OFF; 
*/
:setvar __IsSqlCmdEnabled "True"
GO
IF N'$(__IsSqlCmdEnabled)' NOT LIKE N'True'
    BEGIN
        PRINT N'SQLCMD mode must be enabled to successfully execute this script.';
        SET NOEXEC ON;
    END


GO
USE [$(DatabaseName)];


GO
PRINT N'Creating [dbo].[TieOutBase]...';


GO
CREATE TABLE [dbo].[TieOutBase] (
    [GuestID]      BIGINT   NOT NULL,
    [xPass]        INT      NULL,
    [FacilityID]   BIGINT   NULL,
    [RideID_Entry] INT      NULL,
    [RideTime]     DATETIME NULL,
    [TimeSliceBeg] TIME (7) NULL,
    [TimeSliceEnd] TIME (7) NULL,
    [EntryFlag]    INT      NOT NULL,
    [AbandonFlag]  INT      NOT NULL,
    [MergeFlag]    INT      NOT NULL,
    [VBAFlag]      INT      NOT NULL,
    [LoadTime]     INT      NOT NULL,
    [ExitFlag]     INT      NOT NULL
);


GO
PRINT N'Creating [dbo].[TieOutBase].[IX_FacilityId]...';


GO
CREATE NONCLUSTERED INDEX [IX_FacilityId]
    ON [dbo].[TieOutBase]([FacilityID] ASC);


GO
PRINT N'Creating [dbo].[EventsXBRCDaily].[IX_CreatedDate]...';


GO
CREATE NONCLUSTERED INDEX [IX_CreatedDate]
    ON [dbo].[EventsXBRCDaily]([CreatedDate] ASC);


GO
PRINT N'Creating [dbo].[EventsXBRCDaily].[IX_EventId]...';


GO
CREATE NONCLUSTERED INDEX [IX_EventId]
    ON [dbo].[EventsXBRCDaily]([EventId] ASC);


GO
PRINT N'Creating [dbo].[EventsXBRCDaily].[IX_FacilityID]...';


GO
CREATE NONCLUSTERED INDEX [IX_FacilityID]
    ON [dbo].[EventsXBRCDaily]([FacilityID] ASC);


GO
PRINT N'Creating [dbo].[EventsXBRCDaily].[IX_TimeStamp]...';


GO
CREATE NONCLUSTERED INDEX [IX_TimeStamp]
    ON [dbo].[EventsXBRCDaily]([Timestamp] ASC);


GO
PRINT N'Creating [dbo].[GuestStates].[IX_UpdatedTime]...';


GO
CREATE NONCLUSTERED INDEX [IX_UpdatedTime]
    ON [dbo].[GuestStates]([UpdatedTime] ASC) WITH (FILLFACTOR = 70);


GO
PRINT N'Altering [dbo].[sp_LRR_ETL]...';


GO
ALTER
PROCEDURE [dbo].[sp_LRR_ETL]
as

BEGIN TRY

declare @starttime datetime
declare @cutofftime datetime
declare @LastEventID bigint
declare @PreviousEventID bigint
set @cutofftime = getutcdate()
declare @UTCDefaultOffset int
declare @UTCDLSOffset int
declare @UTCCurrentOffset int
declare @DLSStart smalldatetime, @DLSEnd smalldatetime
declare @controlOffset varchar (32)

--standard UTC offset
select top 1 @UTCDefaultOffset = UTCDefaultOffset 
	from xiFacilities (nolock)
	where parkFacilityID in (80007944)

--UTC offset with daylight savings
set @UTCDLSOffset = @UTCDefaultOffset+1

set @DLSStart = (select dbo.fn_GetDaylightSavingsTimeStart(DATEADD(HH,@UTCDefaultOffset,@cutofftime)))
set @DLSEnd = (select  dbo.fn_GetDaylightSavingsTimeEnd(DATEADD(HH,@UTCDefaultOffset,@cutofftime)))

select @UTCCurrentOffset = 
	case 
		when DATEADD(HH,@UTCDefaultOffset,@cutofftime) between @DLSStart and @DLSEnd then @UTCDLSOffset
		else @UTCDefaultOffset
	end 

select @starttime = isnull(max(Timestamp),'1900-01-01') from syncControl (nolock) where status = 1


truncate table EventDelta
truncate table QueueCountsCache

DELETE from Event2HoursRollingStandBy where CreatedDate < DATEADD(MINUTE,-120,getutcdate())
DELETE from Event15MinutesRollingFastPass where CreatedDate < DATEADD(MINUTE,-15,getutcdate())

--insert EventDelta

truncate table EventDelta
insert EventDelta
select EventId,
	GuestID,
	RideNumber,
	xPass,
	x.FacilityID,
	EventTypeID,
	ReaderLocation = case when ReaderLocation = 'FPP-Merge' then 0 else 1 end,
	Timestamp,
	BandTypeID,
	CreatedDate
	from rdr.Event e (nolock)
	join rdr.Facility f (nolock) on f.FacilityID = e.FacilityID
	join xiFacilities x on x.FacilityID = f.FacilityName
	where CreatedDate between DATEADD(SECOND,-10,@starttime) and getutcdate()
	
	
set @controlOffset = convert(varchar, DATEDIFF(MILLISECOND, @cutofftime, GETUTCDATE()))

print 'Delta Pull End'
print @controlOffset
--Reports Start
	
TRUNCATE TABLE BadReadsTemp

INSERT BadReadsTemp
select GuestID ,RideNumber, xPass, FacilityID, EventTypeID 
FROM dbo.EventDelta
GROUP BY GuestID ,RideNumber, xPass, FacilityID, EventTypeID
HAVING COUNT(*) > 1

DELETE FROM EventDelta
WHERE GuestID in (SELECT GuestID FROM BadReadsTemp)

MERGE Event2HoursRollingStandBy as TARGET
USING EventDelta (NOLOCK) AS SOURCE
on (TARGET.EventId = SOURCE.EventId)-- AND SOURCE.xPass = 0)
WHEN MATCHED 
	THEN UPDATE 
	SET 
	TARGET.GuestID = SOURCE.GuestID
	,TARGET.FacilityID = SOURCE.FacilityID
	,TARGET.RideNumber = SOURCE.RideNumber
	,TARGET.xPass = SOURCE.xPass
	,TARGET.EventTypeID = SOURCE.EventTypeID
	,TARGET.ReaderLocationFlag = SOURCE.ReaderLocationFlag	
	,TARGET.Timestamp = SOURCE.Timestamp	
	,TARGET.BandTypeID = SOURCE.BandTypeID
	,TARGET.CreatedDate	= SOURCE.CreatedDate	
WHEN NOT MATCHED BY TARGET-- AND SOURCE.xPass = 0
	THEN INSERT (EventId,GuestID,FacilityID,RideNumber,xPass,EventTypeID,ReaderLocationFlag,Timestamp,BandTypeID,CreatedDate)
	VALUES(SOURCE.EventId,SOURCE.GuestID,SOURCE.FacilityID,
	SOURCE.RideNumber,SOURCE.xPass,SOURCE.EventTypeID,
	SOURCE.ReaderLocationFlag,SOURCE.Timestamp,SOURCE.BandTypeID,SOURCE.CreatedDate);

set @controlOffset = convert(varchar, DATEDIFF(MILLISECOND, @cutofftime, GETUTCDATE()))

print 'Two Hour Events End'
print @controlOffset

MERGE Event15MinutesRollingFastPass as TARGET
USING EventDelta AS SOURCE
on (TARGET.EventId = SOURCE.EventId AND SOURCE.xPass = 1)
WHEN MATCHED 
	THEN UPDATE 
	SET 
	TARGET.GuestID = SOURCE.GuestID
	,TARGET.FacilityID = SOURCE.FacilityID
	,TARGET.RideNumber = SOURCE.RideNumber
	,TARGET.xPass = SOURCE.xPass
	,TARGET.EventTypeID = SOURCE.EventTypeID
	,TARGET.ReaderLocationFlag = SOURCE.ReaderLocationFlag	
	,TARGET.Timestamp = SOURCE.Timestamp	
	,TARGET.BandTypeID = SOURCE.BandTypeID
	,TARGET.CreatedDate	= SOURCE.CreatedDate	
WHEN NOT MATCHED BY TARGET AND SOURCE.xPass = 1
	THEN INSERT (EventId,GuestID,FacilityID,RideNumber,xPass,EventTypeID,ReaderLocationFlag,Timestamp,BandTypeID,CreatedDate)
	VALUES(SOURCE.EventId,SOURCE.GuestID,SOURCE.FacilityID,
	SOURCE.RideNumber,SOURCE.xPass,SOURCE.EventTypeID,
	SOURCE.ReaderLocationFlag,SOURCE.Timestamp,SOURCE.BandTypeID,SOURCE.CreatedDate);

set @controlOffset = convert(varchar, DATEDIFF(MILLISECOND, @cutofftime, GETUTCDATE()))

print '15 Minute Events End'
print @controlOffset

MERGE EventsXBRCDaily as TARGET
USING EventDelta AS SOURCE
on (TARGET.EventId = SOURCE.EventId)
WHEN MATCHED 
	THEN UPDATE 
	SET 
	TARGET.GuestID = SOURCE.GuestID
	,TARGET.FacilityID = SOURCE.FacilityID
	,TARGET.RideNumber = SOURCE.RideNumber
	,TARGET.xPass = SOURCE.xPass
	,TARGET.EventTypeID = SOURCE.EventTypeID
	,TARGET.ReaderLocationFlag = SOURCE.ReaderLocationFlag	
	,TARGET.Timestamp = SOURCE.Timestamp	
	,TARGET.BandTypeID = SOURCE.BandTypeID	
	,TARGET.CreatedDate	= SOURCE.CreatedDate		
WHEN NOT MATCHED BY TARGET
	THEN INSERT (EventId,GuestID,FacilityID,RideNumber,xPass,EventTypeID,ReaderLocationFlag,Timestamp,BandTypeID,CreatedDate)
	VALUES(SOURCE.EventId,SOURCE.GuestID,SOURCE.FacilityID,
	SOURCE.RideNumber,SOURCE.xPass,SOURCE.EventTypeID,
	SOURCE.ReaderLocationFlag,SOURCE.Timestamp,SOURCE.BandTypeID,SOURCE.CreatedDate);

set @controlOffset = convert(varchar, DATEDIFF(MILLISECOND, @cutofftime, GETUTCDATE()))

print 'Daily Events End'
print @controlOffset
--Reports Start

truncate table [QueueCountsCacheStep01]

insert [QueueCountsCacheStep01]
SELECT 'E2M', t1.xPass, t1.facilityID, StandByCount = count(distinct t1.GuestID) 
from (
-- all eligible entry events
select guestID, RideNumber, facilityID, xPass
	from Event2HoursRollingStandBy (nolock)
	where EventTypeID = 1 --'Entry'
	--and  ReaderLocationFlag = 1 --'FPP-Merge'
) as t1
left join (
-- minus all guests who have hit merge or abandon state
select GuestID, RideNumber, facilityID, xPass
		from Event2HoursRollingStandBy (nolock)
	where EventTypeID in (2,3)--('Merge','Abandon')
) as t2 on t1.RideNumber = t2.RideNumber		
	and t1.guestID = t2.guestID
	and t1.facilityID = t2.facilityID
	and t1.xPass = t2.xPass
	where t2.GuestID is NULL
	group by t1.facilityID, t1.xPass
	
insert [QueueCountsCacheStep01]	
SELECT 'M2L', t1.xPass, t1.facilityID, MergeCount = count(distinct t1.GuestID) 
from (
-- all eligible entry events
select guestID, RideNumber, facilityID, xPass
	from Event2HoursRollingStandBy (nolock)
	where EventTypeID = 2 --'Merge'
) as t1
left join (
-- minus all guests who have hit load state
select GuestID, RideNumber, facilityID, xPass
		from Event2HoursRollingStandBy (nolock)
	where EventTypeID = 4 --Load
) as t2 on t1.RideNumber = t2.RideNumber		
	and t1.guestID = t2.guestID
	and t1.facilityID = t2.facilityID
	and t1.xPass = t2.xPass
	where t2.GuestID is NULL
	group by t1.facilityID, t1.xPass

insert [QueueCountsCacheStep01]
SELECT 'L2E', t1.xPass, t1.facilityID, LoadCount = count(distinct t1.GuestID) 
from (
-- all eligible entry events
select guestID, RideNumber, facilityID, xPass
	from Event2HoursRollingStandBy (nolock)
	where EventTypeID = 4 --'Load'
) as t1
left join (
-- minus all guests who have hit load state
select GuestID, RideNumber, facilityID, xPass
		from Event2HoursRollingStandBy (nolock)
	where EventTypeID = 5 --Exit
) as t2 on t1.RideNumber = t2.RideNumber		
	and t1.guestID = t2.guestID
	and t1.facilityID = t2.facilityID
	and t1.xPass = t2.xPass
	where t2.GuestID is NULL
	group by t1.facilityID, t1.xPass


set @controlOffset = convert(varchar, DATEDIFF(MILLISECOND, @cutofftime, GETUTCDATE()))

print 'Queue Counts Step 01 End'
print @controlOffset
--Reports Start

truncate table TieOutBase
insert TieOutBase
SELECT GuestID,	xPass, FacilityID, RideID_Entry, 
	RideTime = dateadd(HOUR,-4,isnull(EntryTime, isnull(MergeTime, isnull (LoadTime, ExitTime)))),
	TimeSliceBeg, TimeSliceEnd,
	EntryFlag = case when EntryTime is NULL then 0 else 1 end,
	AbandonFlag = case when AbandonTime is NULL then 0 else 1 end,
	MergeFlag = case when MergeTime is NULL then 0 else 1 end,
	VBAFlag = case when VBATime is NULL then 0 else 1 end,
	LoadTime = case when LoadTime is NULL then 0 else 1 end,
	ExitFlag = case when ExitTime is NULL then 0 else 1 end
	FROM GuestStates g (NOLOCK)
	join TimeSlices t (NOLOCK) on convert(time,dateadd(HOUR,-4,isnull(EntryTime, isnull(MergeTime, isnull (LoadTime, ExitTime))))) between TimeSliceBeg and TimeSliceEnd
	and TimeSlicesType = '15Mins'
--	where updatedtime between convert(datetime, convert(date,getdate()))+.32 and getutcdate()
	where updatedtime between dateadd(MINUTE, -150, getutcdate()) and getutcdate()
	

truncate table 	LocationCoverage
insert	LocationCoverage
select x.parkFacilityID, x.FacilityID, EventCount = count(t.facilityId), 
	EntryFlag = isnull(SUM(EntryFlag),0),
	AbandonFlag = isnull(SUM(AbandonFlag),0),
	MergeFlag = isnull(SUM(MergeFlag),0),
	VBAFlag = isnull(SUM(VBAFlag),0),
	LoadFlag = isnull(SUM(LoadTime),0),
	ExitFlag = isnull(SUM(ExitFlag),0)
	from xiFacilities x
	left join TieOutBase t (nolock) on x.facilityId = t.facilityId 
	group by x.parkFacilityID, x.FacilityID


set @controlOffset = convert(varchar, DATEDIFF(MILLISECOND, @cutofftime, GETUTCDATE()))

print 'Location Coverage End'
print @controlOffset
--Reports Start

TRUNCATE TABLE QueueCountsCache	
insert QueueCountsCache
select x.parkFacilityID, x.facilityID, EntryCount = ISNULL(EntryCount,0), MergeCount = ISNULL(MergeCount,0)
from xiFacilities x (nolock)
left join(
SELECT t1.facilityID, EntryCount = count(distinct t1.GuestID) 
from (
-- all eligible entry events
select guestID, RideNumber, facilityID, xPass, Timestamp
	from [Event2HoursRollingStandBy] (nolock)
	where EventTypeID = 1 --'Entry'
	--and  ReaderLocationFlag = 1 --'FPP-Merge'
) as t1
left join (
-- minus all guests who have hit merge or abandon state
select GuestID, RideNumber, facilityID, xPass, Timestamp
		from [Event2HoursRollingStandBy] (nolock)
	where  EventTypeID in (2,3)--('Merge','Abandon')
) as t2 on t1.RideNumber = t2.RideNumber		
	and t1.guestID = t2.guestID
	and t1.facilityID = t2.facilityID
	where t2.GuestID is NULL
	group by t1.facilityID )as t1 on t1.facilityID = x.FacilityID

left join(
SELECT facilityID, MergeCount = count(distinct GuestID)
	from [Event2HoursRollingStandBy] (nolock)
	where EventTypeID = 2 --'Merge'
    and TimeStamp >= DATEADD(MINUTE,-5, GETUTCDATE())
    group by facilityID) as t2 on t2.facilityID = x.FacilityID
    
truncate table QueueCountsCacheLRR

insert QueueCountsCacheLRR
select  t1.parkFacilityID, t1.FacilityID, 
StandByCount = isnull(t2.EntryCount,0) + isnull(t3.EntryCount,0), 
FPCount = isnull(t4.EntryCount,0),
MergeCount = isnull(t2.MergeCount,0) + isnull(t3.MergeCount,0), 
LoadCount = isnull(t2.LoadCount,0)
from xiFacilities t1
left join (
select l.ParkFacilityID,
l.FacilityID,
xPass,
EntryCount,
MergeCount,
LoadCount
	from QueueCountsCacheWorking q (nolock)
	join LocationCoverage l on l.facilityId = q.facilityId
	where ExitFlag <> 0
	and xPass = 0) as t2 on t1.facilityId = t2.facilityId
left join (
select  l.ParkFacilityID,
l.FacilityID,
xPass,
EntryCount,
MergeCount,
LoadCount = 0
	from QueueCountsCacheWorking q (nolock)
	join LocationCoverage l on l.facilityId = q.facilityId
	where ExitFlag = 0
	and xPass = 0) as t3 on t1.facilityId = t3.facilityId
left join (
select  l.ParkFacilityID,
l.FacilityID,
xPass,
EntryCount,
MergeCount = 0,
LoadCount = 0
	from QueueCountsCacheWorking q (nolock)
	join LocationCoverage l on l.facilityId = q.facilityId
	where LoadFlag = 0) as t4 on t1.facilityId = t4.facilityId
 
    
BEGIN TRAN PUBLISH3


truncate table QueueCounts

truncate table QueueCountsLRR

insert QueueCounts (ParkFacilityID,
FacilityID,
EntryCount,
MergeCount) 
select * from QueueCountsCache (nolock)

insert QueueCountsLRR (parkFacilityID,
FacilityID,
StandByCount,
FPCount,
MergeCount,
LoadCount) 
select * from QueueCountsCacheLRR (nolock)


COMMIT TRAN PUBLISH3	


truncate table QueueCountsCache
truncate table QueueCountsCacheLRR

set @controlOffset = convert(varchar, DATEDIFF(MILLISECOND, @cutofftime, GETUTCDATE()))

print 'Queue Counts Step 02 End'
print @controlOffset
--Reports Start


print 'GUEST STATES'
-----GUEST STATES-----    

MERGE GuestStates as TARGET
USING EventDelta AS SOURCE
on (TARGET.GuestID = SOURCE.GuestID 
	AND TARGET.RideID_Entry = SOURCE.RideNumber
	AND TARGET.xPass = SOURCE.xPass
	AND TARGET.FacilityID = SOURCE.FacilityID
	AND EventTypeID = 1)--Entry
WHEN MATCHED 
	THEN UPDATE 
	SET 
	TARGET.GuestID = SOURCE.GuestID
	,TARGET.xPass = SOURCE.xPass
	,TARGET.FacilityID = SOURCE.FacilityID
	,TARGET.RideID_Entry = SOURCE.RideNumber
	,TARGET.EntryTime = SOURCE.Timestamp
	,TARGET.LastUpdateEventTypeID = SOURCE.EventTypeID 
	,TARGET.UpdatedTime = getutcdate()		
WHEN NOT MATCHED BY TARGET AND EventTypeID = 1
	THEN INSERT (GuestID,xPass,FacilityID, RideID_Entry,EntryTime,LastUpdateEventTypeID)
	VALUES(SOURCE.GuestID,SOURCE.xPass,SOURCE.FacilityID,SOURCE.RideNumber,SOURCE.Timestamp,SOURCE.EventTypeID);
	
MERGE GuestStates as TARGET
USING EventDelta AS SOURCE
on (TARGET.GuestID = SOURCE.GuestID 
	AND TARGET.RideID_Entry = SOURCE.RideNumber
 	AND TARGET.xPass = SOURCE.xPass
	AND TARGET.FacilityID = SOURCE.FacilityID
	AND EventTypeID = 2)--Merge
WHEN MATCHED 
	THEN UPDATE 
	SET 
	TARGET.GuestID = SOURCE.GuestID
	,TARGET.xPass = SOURCE.xPass
	,TARGET.FacilityID = SOURCE.FacilityID
	,TARGET.RideID_Merge = SOURCE.RideNumber
	,TARGET.MergeTime = SOURCE.Timestamp
	,TARGET.MergeWaitTimeInMinutes = DATEDIFF(MINUTE,TARGET.EntryTime,SOURCE.Timestamp)	
	,TARGET.LastUpdateEventTypeID = SOURCE.EventTypeID 
	,TARGET.UpdatedTime = getutcdate()	
WHEN NOT MATCHED BY TARGET AND EventTypeID = 2
	THEN INSERT (GuestID,xPass,FacilityID, RideID_Entry, RideID_Merge,MergeTime,LastUpdateEventTypeID)
	VALUES(SOURCE.GuestID,SOURCE.xPass,SOURCE.FacilityID,SOURCE.RideNumber,SOURCE.RideNumber,SOURCE.Timestamp,SOURCE.EventTypeID);

MERGE GuestStates as TARGET
USING EventDelta AS SOURCE
on (TARGET.GuestID = SOURCE.GuestID 
	AND TARGET.RideID_Entry = SOURCE.RideNumber
 	AND TARGET.xPass = SOURCE.xPass
	AND TARGET.FacilityID = SOURCE.FacilityID
	AND EventTypeID = 3)--Abandon
WHEN MATCHED 
	THEN UPDATE 
	SET 
	TARGET.GuestID = SOURCE.GuestID
	,TARGET.xPass = SOURCE.xPass
	,TARGET.FacilityID = SOURCE.FacilityID
	,TARGET.RideID_Abandon = SOURCE.RideNumber
	,TARGET.AbandonTime = SOURCE.Timestamp
	,TARGET.LastUpdateEventTypeID = SOURCE.EventTypeID 
	,TARGET.UpdatedTime = getutcdate()	
WHEN NOT MATCHED BY TARGET AND EventTypeID = 3
	THEN INSERT (GuestID,xPass,FacilityID, RideID_Entry,RideID_Abandon,AbandonTime,LastUpdateEventTypeID)
	VALUES(SOURCE.GuestID,SOURCE.xPass,SOURCE.FacilityID,SOURCE.RideNumber,SOURCE.RideNumber,SOURCE.Timestamp,SOURCE.EventTypeID);
	
MERGE GuestStates as TARGET
USING EventDelta AS SOURCE
on (TARGET.GuestID = SOURCE.GuestID 
	AND TARGET.RideID_Entry = SOURCE.RideNumber
 	AND TARGET.xPass = SOURCE.xPass
	AND TARGET.FacilityID = SOURCE.FacilityID
	AND EventTypeID = 4)--Load
WHEN MATCHED 
	THEN UPDATE 
	SET 
	TARGET.GuestID = SOURCE.GuestID
	,TARGET.xPass = SOURCE.xPass
	,TARGET.FacilityID = SOURCE.FacilityID
	,TARGET.RideID_Load = SOURCE.RideNumber
	,TARGET.LoadTime = SOURCE.Timestamp	
	,TARGET.LoadWaitTimeInMinutes = DATEDIFF(MINUTE,TARGET.EntryTime,SOURCE.Timestamp)
	,TARGET.LastUpdateEventTypeID = SOURCE.EventTypeID 
	,TARGET.UpdatedTime = getutcdate()	
WHEN NOT MATCHED BY TARGET AND EventTypeID = 4
	THEN INSERT (GuestID,xPass,FacilityID, RideID_Entry,RideID_Load,LoadTime,LastUpdateEventTypeID)
	VALUES(SOURCE.GuestID,SOURCE.xPass,SOURCE.FacilityID,SOURCE.RideNumber,SOURCE.RideNumber,SOURCE.Timestamp,SOURCE.EventTypeID);
	
MERGE GuestStates as TARGET
USING EventDelta AS SOURCE
on (TARGET.GuestID = SOURCE.GuestID 
	AND TARGET.RideID_Entry = SOURCE.RideNumber
 	AND TARGET.xPass = SOURCE.xPass
	AND TARGET.FacilityID = SOURCE.FacilityID
	AND EventTypeID = 7)--VBA
WHEN MATCHED 
	THEN UPDATE 
	SET 
	TARGET.GuestID = SOURCE.GuestID
	,TARGET.xPass = SOURCE.xPass
	,TARGET.FacilityID = SOURCE.FacilityID
	,TARGET.RideID_VBA = SOURCE.RideNumber
	,TARGET.VBATime = SOURCE.Timestamp	
	,TARGET.LastUpdateEventTypeID = SOURCE.EventTypeID 
	,TARGET.UpdatedTime = getutcdate()	
WHEN NOT MATCHED BY TARGET AND EventTypeID = 7
	THEN INSERT (GuestID,xPass,FacilityID, RideID_Entry,RideID_VBA, VBATime, LastUpdateEventTypeID)
	VALUES(SOURCE.GuestID,SOURCE.xPass,SOURCE.FacilityID,SOURCE.RideNumber,SOURCE.RideNumber,SOURCE.Timestamp,SOURCE.EventTypeID);
	
		
MERGE GuestStates as TARGET
USING EventDelta AS SOURCE
on (TARGET.GuestID = SOURCE.GuestID 
	AND TARGET.RideID_Entry = SOURCE.RideNumber
 	AND TARGET.xPass = SOURCE.xPass
	AND TARGET.FacilityID = SOURCE.FacilityID
	AND EventTypeID = 5)--Exit
WHEN MATCHED 
	THEN UPDATE 
	SET 
	TARGET.GuestID = SOURCE.GuestID
	,TARGET.RideID_Entry = SOURCE.RideNumber
	,TARGET.xPass = SOURCE.xPass
	,TARGET.FacilityID = SOURCE.FacilityID
	,TARGET.RideID_Exit = SOURCE.RideNumber
	,TARGET.ExitTime = SOURCE.Timestamp	
	,TARGET.ExitWaitTimeInMinutes = DATEDIFF(MINUTE,TARGET.EntryTime,SOURCE.Timestamp)
	,TARGET.LastUpdateEventTypeID = SOURCE.EventTypeID 
	,TARGET.UpdatedTime = getutcdate()	
WHEN NOT MATCHED BY TARGET AND EventTypeID = 5
	THEN INSERT (GuestID,xPass,FacilityID, RideID_Entry, RideID_Exit,ExitTime, LastUpdateEventTypeID)
	VALUES(SOURCE.GuestID,SOURCE.xPass,SOURCE.FacilityID,SOURCE.RideNumber,SOURCE.RideNumber,SOURCE.Timestamp,SOURCE.EventTypeID);   
 
print 'GUEST STATES END'
-----GUEST STATES END-----

set @controlOffset = convert(varchar, DATEDIFF(MILLISECOND, @cutofftime, GETUTCDATE()))

print 'Guest States End'
print @controlOffset
--Reports Start

--Wait Times
BEGIN TRAN PUBLISH05

truncate table WaitTimes 

insert WaitTimes (parkID, facilityId, E2M_FP, E2M_SB, E2L_FP, E2L_SB, M2L)
select parkFacilityID, t1.facilityId, E2M_FP, E2M_SB, E2L_FP, E2L_SB, M2L
	from (
select x.parkFacilityID, x.facilityId, E2M_SB = isnull(E2M,-1), E2L_SB = isnull(E2L,-1), M2L = isnull(M2L,-1)
	from xiFacilities x
	left join (select facilityID
	,xPass = isnull(xPass,-1)
	,E2M = isnull(SUM(E2M)/count(*),-1)
	,E2L = isnull(SUM(E2L)/count(*),-1)
	,M2L = isnull(SUM(M2L)/count(*),-1)
	from vw_GuestStates_15Minutes 
	where E2M is NOT NULL and E2L is NOT NULL and M2L is NOT NULL 
	group by facilityID, xPass) g on g.facilityID = x.facilityID and xPass = 0) as t1
	join(
select x.facilityId, E2M_FP = isnull(E2M,-1), E2L_FP = isnull(E2L,-1)
	from xiFacilities x
	left join (select facilityID
	,xPass = isnull(xPass,-1)
	,E2M = isnull(SUM(E2M)/count(*),-1)
	,E2L = isnull(SUM(E2L)/count(*),-1)
	,M2L = isnull(SUM(M2L)/count(*),-1)
	from vw_GuestStates_15Minutes 
	where E2M is NOT NULL and E2L is NOT NULL and M2L is NOT NULL 
	group by facilityID, xPass) g on g.facilityID = x.facilityID and xPass = 1) as t2 on t1.facilityId = t2.facilityId
	
COMMIT TRAN PUBLISH05	

set @controlOffset = convert(varchar, DATEDIFF(MILLISECOND, @cutofftime, GETUTCDATE()))

print 'Wait Times End'
print @controlOffset
--Reports Start
print '100%'

END TRY
BEGIN CATCH

insert ETL_ExecutionErorrs
select ProcedureName = 'sp_LRR_ETL', 
TimeStamp = GETUTCDATE(), 
ERROR_NUMBER() AS ErrorNumber,
 ERROR_SEVERITY() AS ErrorSeverity,
 ERROR_STATE() AS ErrorState,
 ERROR_PROCEDURE() AS ErrorProcedure,
 ERROR_LINE() AS ErrorLine,
 ERROR_MESSAGE() AS ErrorMessage;

END CATCH
GO
PRINT N'Altering [dbo].[sp_PullParkEntryData]...';


GO
ALTER procedure [dbo].[sp_PullParkEntryData]
as

BEGIN TRY

declare @starttime datetime
declare @cutofftime datetime
set @cutofftime = getutcdate()
declare @UTCDefaultOffset int
declare @UTCDLSOffset int
declare @UTCCurrentOffset int
declare @DLSStart smalldatetime
declare @DLSEnd smalldatetime
declare @Offset bigint
declare @controlOffset bigint
--set @Offset = (select Offset from tempParkEntryTestControl)

--standard UTC offset
select top 1 @UTCDefaultOffset = UTCDefaultOffset 
	from xiFacilities (nolock)
	where parkFacilityID in (80007944)
	
--UTC offset with dajlight savings
set @UTCDLSOffset = @UTCDefaultOffset+1

set @DLSStart = (select dbo.fn_GetDaylightSavingsTimeStart(DATEADD(HH,@UTCDefaultOffset,@cutofftime)))
set @DLSEnd = (select  dbo.fn_GetDaylightSavingsTimeEnd(DATEADD(HH,@UTCDefaultOffset,@cutofftime)))

select @UTCCurrentOffset = 
	case 
		when DATEADD(HH,@UTCDefaultOffset,@cutofftime) between @DLSStart and @DLSEnd then @UTCDLSOffset
		else @UTCDefaultOffset
	end 

select @starttime = isnull(max(Timestamp),'1900-01-01') from syncControl (nolock) where status = 1


print 'ParkEntryEventDelta start'
truncate table ParkEntryEventDelta

insert ParkEntryEventDelta
select distinct PublicId, 
	FacilityID = FacilityName,
	ParkEntryAttemptID,
	EventTypeID,
	--EntryDate = convert(date, TimeStamp), 
	--EntryDateTime = TimeStamp,
EntryDate = convert(date, dateadd(HH, @UTCDLSOffset,TimeStamp)), 
EntryDateTime = dateadd(HH, @UTCDLSOffset,TimeStamp),
--	EntryDate = convert(date, dateadd(SECOND,-1*@Offset,TimeStamp)), 
--	EntryDateTime = dateadd(SECOND,-1*@Offset,TimeStamp),
	ReaderName,
	ReaderLocation,
	ReaderSection,
	ReaderDeviceId,
	ReasonName,
	XbrcReferenceNo
	--select *
	from rdr.[ParkEntryEvent] p
	join rdr.ParkEntryReasonType r on p.ReasonID = r.ReasonTypeID
	join rdr.Facility f on f.FacilityID = p.FacilityID
	where CreatedDate between dateadd(SECOND,-10,@starttime) and GETUTCDATE()
	--where CreatedDate between '2013-06-22 14:01:07.923' and '2013-06-22 16:42:29.247'
	order by 5,6




update t1
set ParkEntryAttemptID = NewParkEntryAttemptID
from ParkEntryEventDelta t1
	join (select EntryDateTime = max(EntryDateTime), NewParkEntryAttemptID = ParkEntryAttemptID+1, PublicID, ParkEntryAttemptID, FacilityID, XbrcReferenceNo, eventtypeid
	from ParkEntryEventDelta 
	group by PublicID, ParkEntryAttemptID, FacilityID, XbrcReferenceNo, eventtypeid
	having COUNT(*) > 1) as t2 on t1.PublicID = t1.PublicID and t1.EntryDateTime = t2.EntryDateTime and t1.eventtypeid = t2.eventtypeid

update t1
set ParkEntryAttemptID = NewParkEntryAttemptID
from ParkEntryEventDelta t1
	join (select EntryDateTime = max(EntryDateTime), NewParkEntryAttemptID = ParkEntryAttemptID+1, PublicID, ParkEntryAttemptID, FacilityID, XbrcReferenceNo, eventtypeid
	from ParkEntryEventDelta 
	group by PublicID, ParkEntryAttemptID, FacilityID, XbrcReferenceNo, eventtypeid
	having COUNT(*) > 1) as t2 on t1.PublicID = t1.PublicID and t1.EntryDateTime = t2.EntryDateTime and t1.eventtypeid = t2.eventtypeid



MERGE XrefGuestIDPublicID as TARGET
USING (select distinct x.publicID, gxplinkid 
	from ParkEntryEventDelta p 
	join PublicID_GxpLinkID_xRef (nolock) x on p.publicID = x.publicID
	where EntryDate = CONVERT(date,getdate())) AS SOURCE
on (TARGET.PublicID = SOURCE.PublicID
	and TARGET.GuestID = SOURCE.GXPLinkID)
WHEN MATCHED 
	THEN UPDATE 
	SET 
	TARGET.PublicID = SOURCE.PublicID
	,TARGET.GuestID = SOURCE.GXPLinkID
WHEN NOT MATCHED BY TARGET
	THEN INSERT (PublicID,GuestID)
	VALUES(SOURCE.PublicID,SOURCE.GXPLinkID);


--select COUNT(*)  from ParkEntryMaster


print 'TAPPED'
MERGE ParkEntryMaster as TARGET
USING (select top 10000 PublicId,
FacilityID,
ParkEntryAttemptID,
EventTypeID,
EntryDate,
EntryDateTime = max(EntryDateTime),
ReaderName,
ReaderLocation,
ReaderSection,
ReaderDeviceId,
Reason,
XbrcReferenceNo 
	from ParkEntryEventDelta
group by 
PublicId,
FacilityID,
ParkEntryAttemptID,
EventTypeID,
EntryDate,
ReaderName,
ReaderLocation,
ReaderSection,
ReaderDeviceId,
Reason,
XbrcReferenceNo
order by max(EntryDateTime)) AS SOURCE
on (TARGET.PublicID = SOURCE.PublicID
	AND TARGET.ParkEntryAttemptID = SOURCE.ParkEntryAttemptID
	AND TARGET.FacilityID = SOURCE.FacilityID
	AND TARGET.XbrcReferenceNo = SOURCE.XbrcReferenceNo
	AND EventTypeID = 8)--TAPPED
WHEN MATCHED 
	THEN UPDATE 
	SET 
	TARGET.PublicID = SOURCE.PublicID
	,TARGET.FacilityID = SOURCE.FacilityID
	,TARGET.ParkEntryAttemptID = SOURCE.ParkEntryAttemptID
	,TARGET.EntryDate = SOURCE.EntryDate
	,TARGET.TappedTime = SOURCE.EntryDateTime
	,TARGET.ReaderName = SOURCE.ReaderName
	,TARGET.ReaderLocation = SOURCE.ReaderLocation
	,TARGET.ReaderSection = SOURCE.ReaderSection
	,TARGET.ReaderDeviceID = SOURCE.ReaderDeviceID
	,TARGET.XbrcReferenceNo = SOURCE.XbrcReferenceNo
	,TARGET.UpdatedTime = getutcdate()		
WHEN NOT MATCHED BY TARGET AND EventTypeID = 8
	THEN INSERT (PublicID ,FacilityID ,ParkEntryAttemptID ,EntryDate, TappedTime, ReaderName ,ReaderLocation,ReaderSection ,ReaderDeviceID ,XbrcReferenceNo)
	VALUES(SOURCE.PublicID ,SOURCE.FacilityID ,SOURCE.ParkEntryAttemptID ,SOURCE.EntryDate, SOURCE.EntryDateTime, SOURCE.ReaderName
	,SOURCE.ReaderLocation,SOURCE.ReaderSection ,SOURCE.ReaderDeviceID ,SOURCE.XbrcReferenceNo);

--select * from ParkEntryMaster	order by isnull(tappedtime,isnull(hasenteredtime,bluelanetime))
		
set @controlOffset = convert(varchar, DATEDIFF(MILLISECOND, @cutofftime, GETUTCDATE()))
print @controlOffset

print 'HASENTERED'


MERGE ParkEntryMaster as TARGET
USING (select top 10000  PublicId,
FacilityID,
ParkEntryAttemptID,
EventTypeID,
EntryDate,
EntryDateTime = max(EntryDateTime),
ReaderName,
ReaderLocation,
ReaderSection,
ReaderDeviceId,
Reason,
XbrcReferenceNo 
	from ParkEntryEventDelta
group by 
PublicId,
FacilityID,
ParkEntryAttemptID,
EventTypeID,
EntryDate,
ReaderName,
ReaderLocation,
ReaderSection,
ReaderDeviceId,
Reason,
XbrcReferenceNo
order by max(EntryDateTime)) AS SOURCE
on (TARGET.PublicID = SOURCE.PublicID
	AND TARGET.ParkEntryAttemptID = SOURCE.ParkEntryAttemptID
	AND TARGET.FacilityID = SOURCE.FacilityID
	AND TARGET.XbrcReferenceNo = SOURCE.XbrcReferenceNo
	AND EventTypeID = 9)--HASENTERED
WHEN MATCHED 
	THEN UPDATE 
	SET 
	TARGET.PublicID = SOURCE.PublicID
	,TARGET.FacilityID = SOURCE.FacilityID
	,TARGET.ParkEntryAttemptID = SOURCE.ParkEntryAttemptID
	,TARGET.HasEnteredTime = SOURCE.EntryDateTime
	,TARGET.HasEnteredReason = SOURCE.Reason
	,TARGET.XbrcReferenceNo = SOURCE.XbrcReferenceNo
	,TARGET.UpdatedTime = getutcdate()		
WHEN NOT MATCHED BY TARGET AND EventTypeID = 9
	THEN INSERT (PublicID ,FacilityID ,ParkEntryAttemptID ,HasEnteredTime ,HasEnteredReason ,XbrcReferenceNo)
	VALUES(SOURCE.PublicID ,SOURCE.FacilityID ,SOURCE.ParkEntryAttemptID ,SOURCE.EntryDateTime , SOURCE.Reason, SOURCE.XbrcReferenceNo);
	
print 'BLUELANE'

MERGE ParkEntryMaster as TARGET
USING (select top 10000  PublicId,
FacilityID,
ParkEntryAttemptID,
EventTypeID,
EntryDate,
EntryDateTime = max(EntryDateTime),
ReaderName,
ReaderLocation,
ReaderSection,
ReaderDeviceId,
Reason,
XbrcReferenceNo 
	from ParkEntryEventDelta
group by 
PublicId,
FacilityID,
ParkEntryAttemptID,
EventTypeID,
EntryDate,
ReaderName,
ReaderLocation,
ReaderSection,
ReaderDeviceId,
Reason,
XbrcReferenceNo
order by max(EntryDateTime)) AS SOURCE
on (TARGET.PublicID = SOURCE.PublicID
	AND TARGET.ParkEntryAttemptID = SOURCE.ParkEntryAttemptID
	AND TARGET.FacilityID = SOURCE.FacilityID
	AND TARGET.XbrcReferenceNo = SOURCE.XbrcReferenceNo
	AND EventTypeID = 10)--BLUELANE
WHEN MATCHED 
	THEN UPDATE 
	SET 
	TARGET.PublicID = SOURCE.PublicID
	,TARGET.FacilityID = SOURCE.FacilityID
	,TARGET.ParkEntryAttemptID = SOURCE.ParkEntryAttemptID
	,TARGET.BlueLaneTime = SOURCE.EntryDateTime
	,TARGET.BlueLaneReason = SOURCE.Reason
	,TARGET.XbrcReferenceNo = SOURCE.XbrcReferenceNo
	,TARGET.UpdatedTime = getutcdate()		
WHEN NOT MATCHED BY TARGET AND EventTypeID = 10
	THEN INSERT (PublicID ,FacilityID ,ParkEntryAttemptID ,BlueLaneTime ,BlueLaneReason ,XbrcReferenceNo)
	VALUES(SOURCE.PublicID ,SOURCE.FacilityID ,SOURCE.ParkEntryAttemptID ,SOURCE.EntryDateTime , SOURCE.Reason, SOURCE.XbrcReferenceNo);
	
print 'ABANDONED'

MERGE ParkEntryMaster as TARGET
USING (select top 10000  PublicId,
FacilityID,
ParkEntryAttemptID,
EventTypeID,
EntryDate,
EntryDateTime = max(EntryDateTime),
ReaderName,
ReaderLocation,
ReaderSection,
ReaderDeviceId,
Reason,
XbrcReferenceNo 
	from ParkEntryEventDelta
group by 
PublicId,
FacilityID,
ParkEntryAttemptID,
EventTypeID,
EntryDate,
ReaderName,
ReaderLocation,
ReaderSection,
ReaderDeviceId,
Reason,
XbrcReferenceNo
order by max(EntryDateTime)) AS SOURCE
on (TARGET.PublicID = SOURCE.PublicID
	AND TARGET.ParkEntryAttemptID = SOURCE.ParkEntryAttemptID
	AND TARGET.FacilityID = SOURCE.FacilityID
	AND TARGET.XbrcReferenceNo = SOURCE.XbrcReferenceNo
	AND EventTypeID = 11)--ABANDONED
WHEN MATCHED 
	THEN UPDATE 
	SET 
	TARGET.PublicID = SOURCE.PublicID
	,TARGET.FacilityID = SOURCE.FacilityID
	,TARGET.ParkEntryAttemptID = SOURCE.ParkEntryAttemptID
	,TARGET.AbandonedTime = SOURCE.EntryDateTime
	,TARGET.AbandonedReason = SOURCE.Reason
	,TARGET.XbrcReferenceNo = SOURCE.XbrcReferenceNo
	,TARGET.UpdatedTime = getutcdate()		
WHEN NOT MATCHED BY TARGET AND EventTypeID = 11
	THEN INSERT (PublicID ,FacilityID ,ParkEntryAttemptID ,AbandonedTime ,AbandonedReason ,XbrcReferenceNo)
	VALUES(SOURCE.PublicID ,SOURCE.FacilityID ,SOURCE.ParkEntryAttemptID ,SOURCE.EntryDateTime , SOURCE.Reason, SOURCE.XbrcReferenceNo);


set @controlOffset = convert(varchar, DATEDIFF(MILLISECOND, @cutofftime, GETUTCDATE()))
print @controlOffset

print 'RollingCache01'
--Rolling 2 minutes of data for PE lights	
BEGIN TRAN RollingCache01

truncate table ParkEntryMasterRolling2Minutes
truncate table ParkEntryEvent2MinutesRollingDelta

insert ParkEntryMasterRolling2Minutes
select * 
	from ParkEntryMaster
	where UpdatedTime >= dateadd(MINUTE,-2,GETUTCDATE())
	
insert ParkEntryEvent2MinutesRollingDelta(FacilityID, ReaderID, TimeStamp, EventType,TimeSegmentID)
--select FacilityID, ReaderName + '|' + ReaderLocation, TappedTime, 'Tapped' ,TimeSliceID
--	from ParkEntryMasterRolling2Minutes p (nolock)
--	join TimeSlices s on convert(time, p.TappedTime) between TimeSliceBeg and TimeSliceEnd and TimeSlicesType = '15Secs'
--	where TappedTime is NOT NULL
--union all
--insert ParkEntryEvent2MinutesRollingDelta(FacilityID, ReaderID, TimeStamp, EventType,TimeSegmentID)
select FacilityID,  ReaderName + '|' + ReaderLocation, HasEnteredTime, 'HasEntered' ,TimeSliceID
	from ParkEntryMasterRolling2Minutes p (nolock)
	join TimeSlices s on convert(time, p.HasEnteredTime) between TimeSliceBeg and TimeSliceEnd and TimeSlicesType = '15Secs'
	where HasEnteredTime is NOT NULL
union all
--insert ParkEntryEvent2MinutesRollingDelta(FacilityID, ReaderID, TimeStamp, EventType,TimeSegmentID)
select FacilityID,  ReaderName + '|' + ReaderLocation, BlueLaneTime, 'BlueLane' ,TimeSliceID
	from ParkEntryMasterRolling2Minutes p (nolock)
	join TimeSlices s on convert(time, p.BlueLaneTime) between TimeSliceBeg and TimeSliceEnd and TimeSlicesType = '15Secs'
	where BlueLaneTime is NOT NULL

COMMIT TRAN RollingCache01
set @controlOffset = convert(varchar, DATEDIFF(MILLISECOND, @cutofftime, GETUTCDATE()))
print @controlOffset

print 'RollingCache01 end'
--Reader Counts
truncate table 	ParkEntryReaderCountsCache	

insert 	ParkEntryReaderCountsCache		
select EntryDate = isnull(EntryDate,convert(date,dateadd(HH, @UTCDLSOffset,GETUTCDATE()))), FacilityID, ReaderID = ReaderName + '|' + ReaderLocation,
	EventCount = count(*), GuestCount = count(distinct PublicID),
	TappedCount = SUM(case when tappedtime is null then 0 else 1 end), 
	HasEneterdCount = SUM(case when hasenteredtime is null then 0 else 1 end), 
	BlueLaneCount = SUM(case when bluelanetime is null then 0 else 1 end),
	AbandonedCount = SUM(case when abandonedtime is null then 0 else 1 end)
	from ParkEntryMaster (nolock)	 
	--where EntryDate = convert(date,getdate())
	group by EntryDate, FacilityID, ReaderName + '|' + ReaderLocation
	
set @controlOffset = convert(varchar, DATEDIFF(MILLISECOND, @cutofftime, GETUTCDATE()))
print @controlOffset

print 'ParkEntryReaderCountsCache end'
	
BEGIN TRAN RollingCache02

truncate table ParkEntryReaderCounts

insert ParkEntryReaderCounts (EntryDate,
FacilityID,
ReaderID,
EventCount,
GuestCount,
TappedCount,
HasEneterdCount,
BlueLaneCount,
AbandonedCount)
select * from ParkEntryReaderCountsCache
	

COMMIT TRAN RollingCache02

set @controlOffset = convert(varchar, DATEDIFF(MILLISECOND, @cutofftime, GETUTCDATE()))
print @controlOffset

print 'RollingCache02 end'
/*********************************************************************************************************/

END TRY

BEGIN CATCH

insert ETL_ExecutionErorrs
select ProcedureName = 'sp_PullParkEntryData', 
TimeStamp = GETUTCDATE(), 
ERROR_NUMBER() AS ErrorNumber,
 ERROR_SEVERITY() AS ErrorSeverity,
 ERROR_STATE() AS ErrorState,
 ERROR_PROCEDURE() AS ErrorProcedure,
 ERROR_LINE() AS ErrorLine,
 ERROR_MESSAGE() AS ErrorMessage;

END CATCH
GO
PRINT N'Altering [dbo].[usp_LocationTieOut_ETL]...';


GO
ALTER procedure [dbo].[usp_LocationTieOut_ETL] 
@parkID bigint

as

select v1.FacilityID, v1.TimeSliceBeg, v1.TimeSliceEnd,-- count(*), 
	EntryFlag = convert(decimal (6,3),ISNULL(SUM(EntryFlag)*1.0/count(*)*1.0,-1)),--convert(decimal (6,3), case when ISNULL(SUM(EntryFlag)*1.0/count(*)*1.0,-1) = 0 then -1 else ISNULL(SUM(EntryFlag)*1.0/count(*)*1.0,-1) end),
	AbandonFlag = convert(decimal (6,3), case when ISNULL(SUM(AbandonFlag)*1.0/count(*)*1.0,-1) = 0 then -1 else ISNULL(SUM(AbandonFlag)*1.0/count(*)*1.0,-1) end),
	MergeFlag = convert(decimal (6,3), case when ISNULL(SUM(MergeFlag)*1.0/count(*)*1.0,-1) = 0 then -1 else ISNULL(SUM(MergeFlag)*1.0/count(*)*1.0,-1) end),
	VBAFlag = convert(decimal (6,3), case when ISNULL(SUM(VBAFlag)*1.0/count(*)*1.0,-1) = 0 then -1 else ISNULL(SUM(VBAFlag)*1.0/count(*)*1.0,-1) end),
	LoadTime = convert(decimal (6,3), case when ISNULL(SUM(LoadTime)*1.0/count(*)*1.0,-1) = 0 then -1 else ISNULL(SUM(LoadTime)*1.0/count(*)*1.0,-1) end),
	ExitFlag = convert(decimal (6,3), case when ISNULL(SUM(ExitFlag)*1.0/count(*)*1.0,-1) = 0 then -1 else ISNULL(SUM(ExitFlag)*1.0/count(*)*1.0,-1) end)
	from vw_FacilitySlice15Mins v1
	left join vw_TieOutBase v2 on v1.FacilityID = v2.FacilityID and v1.TimeSliceBeg = v2.TimeSliceBeg --and ExitFlag = 1
	join xiFacilities x on x.facilityId = v1.FacilityID and parkFacilityID = @parkID
	where v1.TimeSliceBeg between '08:00:00.0000000' and '22:45:00.0000000'
	group by v1.FacilityID, v1.TimeSliceBeg, v1.TimeSliceEnd
	order by 1, 2, 3
GO
PRINT N'Creating [dbo].[usp_GetEventsForAttractionETL]...';


GO

CREATE procedure usp_GetEventsForAttractionETL
@StartTime datetime = NULL, 
@EndTime datetime = NULL, 
@FacilityID bigint = 80010114

as
begin

	if @StartTime is NULL
	begin
	set @StartTime = dateadd(SECOND,-10, GETUTCDATE())
	end

	if @EndTime is NULL
	begin
	set @EndTime = GETUTCDATE()
	end

select GuestID, xPass, CreatedDate, TimeStamp,
	EventType = case 
	when EventTypeID = 1 then 'Entry'
	when EventTypeID = 2 then 'Merge'
	when EventTypeID = 4 then 'Load'
	end
	from EventsXBRCDaily (nolock)
	where CreatedDate between @StartTime and @EndTime
	and FacilityID = @FacilityID
	and EventTypeID in (1,2,4)	
	order by 3

end
GO
PRINT N'Creating [dbo].[usp_GetEventsToPreHeatAttractionETL]...';


GO


-- This gives me all the events from now to 30 minutes in the past.
CREATE procedure usp_GetEventsToPreHeatAttractionETL  
@CutofTime datetime = NULL, 
@FacilityID bigint = 80010114

as
begin

	if @CutofTime is NULL
	begin
	set @CutofTime = GETUTCDATE()
	end
	

select GuestID, xPass, CreatedDate, TimeStamp,
	EventType = case 
	when EventTypeID = 1 then 'Entry'
	when EventTypeID = 2 then 'Merge'
	when EventTypeID = 4 then 'Load'
	end
	from EventsXBRCDaily (nolock)
	where CreatedDate between dateadd(MINUTE,-30, @CutofTime) and @CutofTime
	and FacilityID = @FacilityID
	and EventTypeID in (1,2,4)
	order by 3

end
GO
PRINT N'Altering [dbo].[sp_callXIETL]...';


GO
ALTER procedure [dbo].[sp_callXIETL]

as

BEGIN TRY


--regular execution - 1.25 seconds wait
IF (select Status from syncControl (nolock) where jobID in (select jobID = MAX(jobid) from syncControl (nolock))) = 1
BEGIN
 IF (select DATEDIFF(MILLISECOND,isnull(TimeCompleted,GETUTCDATE()), GETUTCDATE()) from syncControl (nolock) where jobID in (select jobID = MAX(jobid) from syncControl (nolock))) >= 1250
 BEGIN
 exec sp_LRR_ETL;
 exec sp_PullParkEntryData;
 exec sp_PullAndSyncReportingDataUTC; 
 
 END
END

ELSE

--force ETL sproc execution after 10 seconds wait
IF (select Status from syncControl (nolock) where JobTypeID = 1 and jobID in (select jobID = MAX(jobid) from syncControl (nolock))) = 0
BEGIN
 IF (select DATEDIFF(ss,TimeStarted, GETUTCDATE()) from syncControl (nolock) where jobID in (select jobID = MAX(jobid) from syncControl (nolock))) >= 10
 BEGIN
 exec sp_LRR_ETL;
 exec sp_PullParkEntryData;
 exec sp_PullAndSyncReportingDataUTC
 
 END
END

ELSE

--Nightly job got aborted - force ETL sproc execution after 2 hours wait
IF (select Status from syncControl (nolock) where JobTypeID = 2 and jobID in (select jobID = MAX(jobid) from syncControl (nolock))) = 2
BEGIN
 IF (select DATEDIFF(ss,TimeStarted, GETUTCDATE()) from syncControl (nolock) where jobID in (select jobID = MAX(jobid) from syncControl (nolock))) >= 7200
 BEGIN
 exec sp_LRR_ETL;
 exec sp_PullParkEntryData;
 exec sp_PullAndSyncReportingDataUTC
 
 END
END

--first run - empty synccontrol
IF NOT EXISTS (SELECT TOP 1 JobID from syncControl (nolock))
BEGIN
exec sp_PullAndSyncReportingDataUTC;
exec sp_LRR_ETL; 
exec sp_PullParkEntryData;

END


END TRY
BEGIN CATCH

insert ETL_ExecutionErorrs
select ProcedureName = 'sp_callXIETL', 
TimeStamp = GETUTCDATE(), 
ERROR_NUMBER() AS ErrorNumber,
 ERROR_SEVERITY() AS ErrorSeverity,
 ERROR_STATE() AS ErrorState,
 ERROR_PROCEDURE() AS ErrorProcedure,
 ERROR_LINE() AS ErrorLine,
 ERROR_MESSAGE() AS ErrorMessage;

END CATCH
GO

update [dbo].[schema_version] 
	set [version]= N'1.7.0.0003', [script_name] = N'dbdash-1.7.0.0003.sql', [date_applied] = GETUTCDATE()

PRINT N'Update complete.';


GO
