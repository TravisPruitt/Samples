/**
    @file   TDA8029.cpp
    @author Greg Strange
    @date   April 2012

    Copyright (c) 2012, synapse.com
*/



#include "TDA8029.h"
#include "log.h"
#include "RFIDExceptions.h"
#include "StringLib.h"
#include "ticks.h"
#include <fcntl.h>


using namespace Reader;
using namespace RFID;


#ifdef _WIN32
#define PORT_NAME    "\\\\.\\COM5"
#else
#define PORT_NAME    "/dev/ttyO0"
#endif


#define USE_115K    1



namespace Command { enum Enum {
    Version = 0x0a,
    SetBaud = 0x0d,
    Status = 0xaa,
    CheckForSam = 0x09,
    IdleMode = 0xa2,
    PowerDown = 0xa3,
    SAM_clock = 0x11,
    SAM_5V = 0x6e,
    SAM_3V = 0x6d,
    SAM_off = 0x4d,
    SAM_negotiate = 0x10,
    SAM_command = 0
}; }


const uint8_t ACK = 0x60;
const uint8_t NAK = 0xe0;
const unsigned MaxDataLength = 506;                     // section 4 of AN10207 document from Nxp
const unsigned MaxMessageLength = MaxDataLength + 5;



TDA8029::TDA8029() : 
    _port(NULL), 
    _haveVersion(false),
    _haveSAM(false)
{
}


TDA8029::~TDA8029()
{
    if (_port)
        delete _port;
}


static void reset()
{
#ifndef _WIN32
    int fd = open("/sys/class/gpio/gpio76/value", O_WRONLY);
    if (fd >= 0)
    {
        write(fd, "1", 1);
        sleepMilliseconds(2);
        write(fd, "0", 1);
        close(fd);

        // Give TDA8029 firmware time to restart.
        //   Value arrived at by trial and error.
        //   At 50ms, the first message to TDA8029 would time out.
        //   At 70ms, the first command works.  I added some cushion to 70ms
        //   to arrive at the value used.
        sleepMilliseconds(100);
        LOG_DEBUG("TDA8029 reset");
    }
    else
        LOG_ERROR("Unable to open GPIO for TDA8029 RESET");
#endif
}


/**
    Initialize connection to reader chip. Throws an exception if there are any troubles.
*/
void TDA8029::init()
{
    reset();

    LOG_DEBUG("Initializing radio at 38.4k baud");
    _port = new SerialPort(PORT_NAME);
    if (!init(38400))
    {
        delete _port;
        _port = NULL;
        throw ReaderException("Unable to communicate with reader chip (8029)");
    }

#if defined(USE_115K) && !defined(_WIN32)
    LOG_DEBUG("Changing radio to 115k baud");
    setBaud(115200);
    _port->close();

    if (!init(115200))
    {
        delete _port;
        _port = NULL;
        throw ReaderException("Unable to communicate with reader chip (8029)");
    }
#endif

    getVersion();
}



void TDA8029::setSAMClock()
{
    ByteArray reply;

    uint8_t clock = 2;
    sendCommand(Command::SAM_clock, &clock, 1);
    readReply(Command::SAM_clock, reply);
}


bool TDA8029::init(uint32_t baud)
{
    if (!_port->init(baud, 'n'))
        throw ReaderException("serial port init failed");

    // The very first status request often fails so we try twice
    for (int i = 0; i < 2; ++i)
    {
        try
        {
            getStatus();
            return true;
        }
        catch (ReaderException)
        {
        }
    }

    return false;

}


void TDA8029::getVersion()
{
    ByteArray reply;

    sendCommand(Command::Version, NULL, 0);
    readReply(Command::Version, reply);
    std::string version;

    _firmwareVersion.clear();
    for (unsigned i = 0; i < reply.size(); ++i)
        _firmwareVersion += (char)reply[i];

    _haveVersion = true;
}



void TDA8029::getStatus()
{
    ByteArray reply;

    sendCommand(Command::Status, NULL, 0);
    readReply(Command::Status, reply);
    if (reply.size() != 1)
        throw ReaderException("Unexpected status message reply length, expected 1, got %d", reply.size());

    LOG_DEBUG("Status byte = 0x%02x", reply[0]);

    _haveSAM = (reply[0] & 1) != 0;
    if ( (reply[0] & 2) != 0)
        LOG_WARN("TDA8029 status reports overheating (PTL bit)");

    if ( (reply[0] & 4) != 0)
        LOG_WARN("TDA8029 status reports card reader default (PROTL bit)");

    if ( (reply[0] & 8) != 0)
        LOG_WARN("TDA8029 status reports supervistor activation (SUPL bit)");
}


void TDA8029::idleMode()
{
    ByteArray reply;

    sendCommand(Command::IdleMode, NULL, 0);
    readReply(Command::IdleMode, reply);
}


void TDA8029::setBaud(uint32_t baud)
{
    uint32_t bauds[] = {4800, 9600, 19200, 38400, 57600, 76800, 115200};

    uint8_t i;
    for (i = 0; (i < sizeof(bauds)) && (bauds[i] != baud); ++i) {};
    if (i >= sizeof(bauds))
        throw BugException("No such baud rate available");

    sendCommand(Command::SetBaud, &i, 1);
    // no point in reading reply to this message
}


void TDA8029::turnOnSAM()
{
    LOG_DEBUG("Turning on SAM");
    ByteArray reply;

    // Change the SAM clock frequency from the default ~3.5Mhz to ~7.5Mhz
    // NOTE: The SAM clock is generated by the 8029. The SAM can run at up
    //       to 10Mhz.  This setting is the fastest we can get from the
    //       8029 without going over 10Mhz.  See NXP AN10207 doc for details.
    uint8_t clock_params[] = {2};
    sendCommand(Command::SAM_clock, clock_params, sizeof(clock_params));
    readReply(Command::SAM_clock, reply);

    // Turn on the SAM at 5 volts
    // With our hardware, it must be 5 volts (i.e. don't try the lower voltages)
    const uint8_t params[] = {0};
    sendCommand(Command::SAM_5V, params, sizeof(params));
    readReply(Command::SAM_5V, reply);

    // Increase the SAM baud rate.  The default baud rate used is very slow.
    // This is the fastest baud rate supported by the 8029, but still way below
    // the maximum SAM baud rate.
    const uint8_t negotiate_params[] = {1, 0x18};
    sendCommand(Command::SAM_negotiate, negotiate_params, sizeof(negotiate_params));
    readReply(Command::SAM_negotiate, reply);
}


void TDA8029::turnOffSAM()
{
    LOG_DEBUG("turn off SAM");
    ByteArray reply;
    sendCommand(Command::SAM_off, NULL, 0);
    readReply(Command::SAM_off, reply);
}

void TDA8029::sendSAMCommand(const uint8_t* data, unsigned length)
{
    sendCommand(Command::SAM_command, data, length);
}

void TDA8029::readSAMReply(ByteArray& reply, unsigned timeoutMs)
{
    readReply(Command::SAM_command, reply, timeoutMs);
}


/******************************************************************************
                    Methods for communicating with 8029
******************************************************************************/


void TDA8029::sendCommand(uint8_t command, const uint8_t* data, unsigned length)
{
    ByteArray msg;

    msg.append(0x60);
    msg.append((length >> 8) & 0xff);
    msg.append(length & 0xff);
    msg.append(command);
    if (data && length)
        msg.append(data, length);
    msg.append(calcLRC(msg.data(), msg.size()));

    if (!_port->write(msg.data(), msg.size()))
        throw ReaderException("Timeout writing to reader");

    LOG_TRAFFIC("->NXP: %s", msg.toString().c_str());
}


/**
    Successful replies from the 8029 are formatted as follows:

        <ACK><2 byte length><command><data><LRC>

    Unsuccessful commands look like this:

        <NAK><2 byte length><command><status><LRC>

    If the command is successful, then the <data> portion of the reply is placed in the
    ByteArray provided.
*/
void TDA8029::readReply(uint8_t command, ByteArray& reply, unsigned timeoutMs)
{
    uint8_t buf[MaxMessageLength];
    unsigned index = 0;
    unsigned dataLength = 0;
    unsigned messageLength = 0;

    do
    {
        if (!_port->readByte(buf, timeoutMs))
            goto rx_timeout;
    }
    while (buf[0] != ACK && buf[0] != NAK);

    for (index = 1; index < 4; ++index)
    {
        if (!_port->readByte(buf + index, timeoutMs))
            goto rx_timeout;
    }

    dataLength = (buf[1] << 8) + buf[2];
    if (dataLength > MaxDataLength)
    {
        LOG_TRAFFIC("<=NXP: %s", StringLib::formatBytes(buf, index).c_str());
        throw ReaderException("Data length too long");
    }


    messageLength = index + dataLength + 1;
    while (index < messageLength)
    {
        if (!_port->readByte(buf + index, timeoutMs))
            goto rx_timeout;

        ++index;
    }

    LOG_TRAFFIC("<=NXP: %s", StringLib::formatBytes(buf, index).c_str());

    if (calcLRC(buf, messageLength) != 0)
    {
        throw ReaderException("NXP message check error");
    }

    if (buf[0] == NAK)
    {
        if (dataLength == 1)
            throw ReaderException("NAK from NXP, status code 0x%02x", buf[3]);
        else
            throw ReaderException("NAK from NXP with unexpected data length (%d)", dataLength);
    }

    if (buf[3] != command)
        throw ReaderException("Reply code != command code.  Expected 0x%02x, got 0x%02x", command, buf[3]);

    reply.clear();
    reply.append(buf+4, dataLength);
    return;


rx_timeout:
    LOG_TRAFFIC("<=NXP: %s", StringLib::formatBytes(buf, index).c_str());
    throw ReaderException("NXP message timeout");
}


uint8_t TDA8029::calcLRC(const uint8_t* data, unsigned length)
{
    uint8_t lrc = 0;
    for (unsigned i = 0; i < length; ++i)
        lrc ^= data[i];

    return lrc;
}


